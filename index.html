<!DOCTYPE html>
<html lang="en-US">
<head>
	<title>MTG Deck Prototyper</title>
	<style>
body {
	margin: 0px;
	background-color:rgb(32,32,32);
	min-width: 100%;
	min-height: 100%;
	height:100%;
	width:100%;
	margin:0px;
	padding:0px;
}

html {
	height:100%;
	width:100%;
	min-height: 100%;
	min-width: 100%;
	margin:0px;
	padding:0px;
}

input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
input[type="number"] {
    -moz-appearance: textfield;
}

dd {
	color: rgb(200,200,200);
	padding-bottom: 10px;
}

.W {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiB2ZXJzaW9uPSIxLjEiPjxjaXJjbGUgY3g9IjMwMCIgY3k9IjMwMCIgcj0iMzAwIiBmaWxsPSIjZmZmYmQ1Ii8+PHBhdGggZD0ibTU4Ni4yIDM0Mi40Yy0zOS40LTIyLjItNjQuNi0zMy4zLTc1LjctMzMuMy04LjEgMC0xNC40IDYuMi0xOC45IDE4LjYtNC41IDEyLjQtMTMuNiAxOC41LTI3LjIgMTguNS01LjYgMC0xNi45LTItMzQuMS02LTkuNiAxNC42LTE0LjQgMjQtMTQuNCAyOCAwIDUuNiA0LjEgMTIuMSAxMi40IDE5LjcgOC4zIDcuNiAxNS4yIDExLjMgMjAuOSAxMS4zIDMuNiAwIDguNS0wLjcgMTQuNy0yLjMgNi4yLTEuNSAxMC4zLTIuMyAxMi40LTIuMyA2LjIgMCA5LjMgMTEuNCA5LjMgMzQuMSAwIDIxLjctNSA1NS0xNS4xIDk5LjktMTMuMS01MS41LTI3LTc3LjItNDEuNi03Ny4yLTIgMC02LjIgMS41LTEyLjUgNC42LTYuMyAzLTExIDQuNS0xNCA0LjUtMTQuNiAwLTI3LjctMTMuNC0zOS40LTQwLjEtMjMuMiAzLjUtMzQuOCAxNS40LTM0LjggMzUuNiAwIDEwLjEgNC43IDE4LjIgMTQgMjQuMiA5LjMgNi4xIDE0IDEwLjQgMTQgMTIuOSAwIDEzLjYtMTkuOSAzNC42LTU5LjggNjIuOC0yMS4yIDE1LjEtMzUuOCAyNS43LTQzLjkgMzEuOCA3LTkuMSAxNC4xLTIwLjkgMjEuMi0zNS42IDguMS0xNi42IDEyLjEtMjkuNSAxMi4xLTM4LjYgMC01LTUuOC0xMi4xLTE3LjQtMjEuMi0xMS42LTkuMS0xNy40LTE4LjctMTcuNC0yOC44IDAtOC42IDMtMTkuMiA5LjEtMzEuOC02LjYtNy42LTE0LjQtMTEuNC0yMy41LTExLjQtMjAuMiAwLTMwLjMgNi42LTMwLjMgMTkuNyAwLTkuMSAwLTIuMyAwIDIwLjQgMC41IDE2LjctMTIuMSAyNS0zNy45IDI1LTE5LjcgMC01Mi43LTQuNi05OS4yLTEzLjYgNTIuNS0xMy4xIDc4LjctMjguMyA3OC43LTQ1LjQgMCAyLTEtNC0zLTE4LjItMi0xNS42IDkuMS0yOS44IDMzLjMtNDIuNC00LjUtMjMuMi0xNi42LTM0LjgtMzYuMy0zNC44LTMgMC04LjYgNS4zLTE2LjYgMTUuOS04LjEgMTAuNi0xNS42IDE1LjktMjIuNyAxNS45LTEyLjEgMC0yNy44LTEzLjEtNDYuOS0zOS40LTkuMS0xMy4xLTIzLTMyLjUtNDEuNi01OC4zIDExLjYgNi4xIDIzLjIgMTIuMSAzNC44IDE4LjIgMTUuMSA3LjEgMjcuMyAxMC42IDM2LjMgMTAuNiA3LjEgMCAxNC02LjIgMjAuOC0xOC42IDYuOC0xMi40IDE1LjgtMTguNiAyNi45LTE4LjYgMS41IDAgMTEuNiAzIDMwLjMgOS4xIDkuNi0xNC42IDE0LjQtMjUuNSAxNC40LTMyLjYgMC02LjEtMy43LTEzLTExLTIwLjgtNy4zLTcuOC0xNC0xMS43LTIwLjEtMTEuNy0yLjUgMC02LjQgMC44LTExLjcgMi4zLTUuMyAxLjUtOS4yIDIuMy0xMS43IDIuMy05LjEgMC0xMy42LTExLjQtMTMuNi0zNC4xIDAtNi4xIDUuOC00MC42IDE3LjQtMTAzLjctMC41IDcuNiAyLjggMjEuNyA5LjggNDIuNCA4LjYgMjUuMiAxOC43IDM3LjkgMzAuMyAzNy45IDIgMCA2LjEtMS41IDEyLjEtNC41IDYuMS0zIDEwLjgtNC41IDE0LjQtNC41IDExLjYgMCAyMS4yIDYuNiAyOC44IDE5LjdsMTEuNCAyMC40YzEwLjYgMCAxOS40LTMuOCAyNi41LTExLjMgNy4xLTcuNiAxMC42LTE2LjcgMTAuNi0yNy4zIDAtMTEuMS00LjctMTkuNi0xNC0yNS40LTkuNC01LjgtMTQtMTAuMi0xNC0xMy4yIDAtMTAuNiAxNi43LTI4LjUgNTAtNTMuNyAyNi43LTIwLjIgNDQuMi0zMiA1Mi4yLTM1LjYtMjEuNyAyOS4zLTMyLjYgNTAuNy0zMi42IDY0LjMgMCA3LjEgNC4zIDE0LjYgMTIuOSAyMi43IDEwLjYgOS42IDE2LjcgMTYuNCAxOC4yIDIwLjQgNSAxMS42IDQuNSAyNy41LTEuNSA0Ny43IDEzLjYgOS42IDI0IDE0LjQgMzEgMTQuNCAxNC42IDAgMjEuOS03LjYgMjEuOS0yMi43IDAtMS41LTAuNi02LjMtMS45LTE0LjQtMS4zLTguMS0xLjYtMTIuNi0xLjEtMTMuNiAyLTcuMSAxNS45LTEwLjYgNDEuNi0xMC42IDE2LjIgMCA0OS43IDQuNSAxMDAuNyAxMy42LTExLjEgMy0yNy44IDcuNi01MCAxMy42LTIwLjIgNi4xLTMwLjMgMTIuOS0zMC4zIDIwLjQgMCAzLjUgMS4zIDkuNiAzLjggMTguMiAyLjUgOC42IDMuOCAxNC45IDMuOCAxOC45IDAgNy4xLTQuNSAxMy42LTEzLjYgMTkuN2wtMjUuNyAxOC4yYzYuMSAxMS4xIDEwLjEgMTcuNyAxMi4xIDE5LjcgNSA2LjEgMTEuOSA5LjEgMjAuNCA5LjEgNi4xIDAgMTEuNi01LjMgMTYuNy0xNS45IDUtMTAuNiAxMy4xLTE1LjkgMjQuMi0xNS45IDEzLjYgMCAyOSAxMi42IDQ2LjIgMzcuOSA5LjYgMTQuMiAyNC41IDM1LjYgNDQuNiA2NC40bS0xNjgtNDMuOWMwLTMyLjMtMTEuOS02MC4zLTM1LjYtODQtMjMuNy0yMy43LTUxLjctMzUuNi04NC0zNS42LTMyLjggMC02MS4xIDExLjctODQuOCAzNS4yLTIzLjcgMjMuNS0zNS44IDUxLjYtMzYuMyA4NC40LTAuNSAzMi4zIDExLjUgNjAuMiAzNiA4My42IDI0LjUgMjMuNSA1Mi45IDM1LjIgODUuMiAzNS4yIDM0LjMgMCA2My0xMS4yIDg1LjktMzMuNyAyMy0yMi40IDM0LjItNTAuOCAzMy43LTg1LjFtLTExLjQgMGMwIDMwLjgtMTAuMyA1Ni4zLTMxIDc2LjQtMjAuNyAyMC4yLTQ2LjQgMzAuMy03Ny4yIDMwLjMtMjkuOCAwLTU1LjMtMTAuMy03Ni40LTMxLTIxLjItMjAuNy0zMS44LTQ1LjktMzEuOC03NS43IDAtMjkuMyAxMC43LTU0LjQgMzIuMi03NS4zIDIxLjUtMjAuOSA0Ni44LTMxLjQgNzYuMS0zMS40IDI5LjMgMCA1NC42IDEwLjYgNzYuMSAzMS44IDIxLjQgMjEuMiAzMi4yIDQ2LjIgMzIuMiA3NC45IiBmaWxsPSIjMjExZDE1Ii8+PC9zdmc+);
}
.U {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIj48Y2lyY2xlIGN4PSIzMDAiIGN5PSIzMDAiIHI9IjMwMCIgZmlsbD0iI2FhZTBmYSIvPjxwYXRoIGQ9Im01NDYuOTMgMzc1LjUzYy0yOC43MjIgMjkuMjMtNjQuMSA0My44NDItMTA2LjEzIDQzLjg0Mi00Ny4xNyAwLTg0LjU5LTE2LjE0LTExMi4yNy00OC40NC0yNi4xNS0zMC43NjItMzkuMjItNjkuOTcyLTM5LjIyLTExNy42NCAwLTUxLjI2IDIyLjMwMi0xMDkuNzIgNjYuOS0xNzUuMzQgMzYuMzgtNTMuODE0IDc5LjE5LTEwMC45OCAxMjguNDEtMTQxLjQ4LTcuMTgyIDMyLjgxNC0xMC43NTggNTYuMTMtMTAuNzU4IDY5Ljk3MiAwIDMxLjc5NCA5Ljk4NCA2Mi44MDIgMjkuOTc2IDkzLjA1IDI0LjYxMiAzNS44OCA0My4zMSA2Mi41NiA1Ni4xNCA3OS45NjggMTkuOTkyIDMwLjI2IDI5Ljk4OCA1OS43MyAyOS45ODggODguNDIuMDAxIDQyLjU1OC0xNC4zNDYgNzguNDQtNDMuMDQgMTA3LjY1bS0uNzc0LTE2NC4xN2MtNy42ODYtMTcuMTctMTYuNjYyLTI4LjU3Mi0yNi45MTYtMzQuMjIgMS41MzYgMy4wODQgMi4zMSA3LjQ0IDIuMzEgMTMuMDggMCAxMC43Ny0zLjA3MiAyNi4xNC05LjIzNCA0Ni4xM2wtOS45ODQgMzAuNzYyYzAgMTcuOTQgOC45NTIgMjYuOTE2IDI2LjkwNCAyNi45MTYgMTguOTYgMCAyOC40NTItMTIuNTcgMjguNDUyLTM3LjY4NiAwLTEyLjgwNC0zLjg0LTI3Ljc5Mi0xMS41MzItNDQuOTg4IiBmaWxsPSIjMDYxOTIyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTQyLjAxIDEyNi43OSkiLz48L3N2Zz4=);
}
.B {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiB2ZXJzaW9uPSIxLjEiPjxjaXJjbGUgY3g9IjMwMCIgY3k9IjMwMCIgcj0iMzAwIiBmaWxsPSIjY2JjMmJmIi8+PHBhdGggZD0ibTU0NC4yIDI5MS43YzAgMzMuMS0xMiA1NS43LTM2LjEgNjcuNy03IDMuNS0yOS4xIDguMy02Ni4yIDE0LjMtMjQuMSA0LTM2LjEgMTMuMy0zNi4xIDI3LjhsMCA2MC45YzAgMi41IDAuOCAxMC4zIDIuMyAyMy4zbDIuMyAyNC4xYzAgNy41LTEuOCAxOS44LTUuMyAzNi45LTkuNSAyLTIwLjYgNC4zLTMzLjEgNi44LTQtMTUuMS02LTI1LjMtNi0zMC45IDAtMi41IDAuNi02LjMgMS45LTExLjMgMS4yLTUgMS45LTguOCAxLjktMTEuMyAwLTMuNS0zLjEtMTMuMy05LjQtMjkuM2wtMTEuNyAwYy0xLjUgMi41LTIuMSA1LjgtMS42IDkuOCAyIDguNSAyLjggMTUuOCAyLjMgMjEuOC04LjUgNi0yMC4zIDE0LjEtMzUuNCAyNC4xLTMuNS0xLTQuOC0xLjUtMy44LTEuNWwwLTUzLjRjLTEtMi41LTMuNS0zLjUtNy41LTNsLTkgMC05IDcwLjdjLTcgMC41LTE1LjYgMC41LTI1LjYgMC0zLjUtMTYuNS05LjgtNDEuMS0xOC44LTczLjdsLTYgMGMtNS41IDE3LjYtOC41IDI3LjEtOSAyOC42IDAgMiAwLjYgNS45IDEuOSAxMS43IDEuMiA1LjggMS45IDkuNyAxLjkgMTEuNyAwIDEuNS0wLjUgNS4zLTEuNSAxMS4zbC0yLjMgMTguMWMtMSAxLTIuMyAxLjUtMy44IDEuNS0xNSAwLTI1LjEtMy44LTMwLjEtMTEuMy01LTcuNS03LTE4LjEtNi0zMS42bDYtOTAuM2MwLTEuNSAwLjUtMy41IDEuNS02IDEtMi41IDEuNS00LjMgMS41LTUuMyAwLTQtNC4zLTEyLTEyLjgtMjQuMS0xLjUtMC41LTkuMy0yLjMtMjMuMy01LjMtOC41LTItMjUuMy01LjUtNTAuNC0xMC41LTM0LjYtNi41LTUxLjktMzQuMy01MS45LTgzLjUgMC03My4yIDMwLjEtMTM0LjIgOTAuMy0xODIuOCAyLjUgMTMuNSA2LjggMzEuNiAxMi44IDU0LjIgNC41IDEgMTQuMyAzLjMgMjkuMyA2LjggMyAxIDE4LjMgNi41IDQ1LjkgMTYuNi0xNC4xLTguNS0zMi40LTIyLjMtNTQuOS00MS40LTguNS0xMC0xMi44LTI2LjgtMTIuOC01MC40IDAtNS41IDkuNS0xMiAyOC42LTE5LjYgMTctNyAyOS45LTExIDM4LjQtMTIgMjcuMS0zLjUgNDcuOS01LjMgNjIuNS01LjMgNjIuNyAwIDExMy40IDE2LjEgMTUyIDQ4LjItMTIuNSAxNC42LTM0LjEgMzAuMS02NC43IDQ2LjYgMTIuMSAwLjUgMjkuNi00LjIgNTIuNy0xNC4zIDIzLjEtMTAgMzIuOS0xNSAyOS4zLTE1IDQgMCAxMi4xIDggMjQuMSAyNC4xIDkgMTIgMTYuMyAyMi44IDIxLjggMzIuNCAxNiAyOC42IDI2LjggNTkuNSAzMi40IDkyLjYgMCAxMS42IDAuMiAxOS44IDAuOCAyNC44bDAgNiAwIDB6bS0yODguMiAxMy41YzAtMjEuNi05LjQtNDItMjguMi02MS4zLTE4LjgtMTkuMy0zOS0yOS02MC42LTI5LTE5LjEgMC0zNS45IDguMS01MC40IDI0LjItMTQuNiAxNi4yLTIxLjggMzQuMS0yMS44IDUzLjggMCAxNy4yIDguMyAyOC4zIDI0LjggMzMuMyAxMC41IDMgMjUuMyA0LjggNDQuNCA1LjNsNDEuNCAwYzMzLjYgMC41IDUwLjQtOC4zIDUwLjQtMjYuM204MiA5My4zIDAtMjMuM2MtMy41LTYuNS03LTEzLjMtMTAuNS0yMC4zLTMtMTAtOC41LTI0LjEtMTYuNi00Mi4xbC04LjMgODhjMCA3LTEuNSAxMC41LTQuNSAxMC41LTIgMC0zLjUtMC41LTQuNS0xLjUtMy41LTUzLjItNS4zLTc2LjItNS4zLTY5LjJsMC0yNi4zYy0xLTEuNS0yLjItMi4zLTMuNy0yLjMtMTcuMSAxNy42LTI1LjYgNDUuOS0yNS42IDg1IDAgMjEuNiAyIDM0LjkgNiAzOS45IDQtMSA4LjUtMi44IDEzLjUtNS4zIDItMSA3LjgtMS41IDE3LjMtMS41IDkuNSAwIDIxLjEgMyAzNC42IDkgNSAwIDcuNS0xMy41IDcuNS00MC42bTE3MC4xLTEwNC44YzAtMjAuMi03LjUtMzguMi0yMi42LTU0LjEtMTUuMS0xNS45LTMyLjQtMjMuOC01MS45LTIzLjgtMjEuMSAwLTQwLjggOS42LTU5LjEgMjktMTguMyAxOS4zLTI3LjUgMzkuNS0yNy41IDYwLjYgMCAxNy42IDguNSAyNi4zIDI1LjYgMjYuM2w4Ni41IDBjMzIuNi0wLjUgNDguOS0xMy4xIDQ4LjktMzcuOSIgZmlsbD0iIzEzMGMwZSIvPjwvc3ZnPg==);
}
.R {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiB2ZXJzaW9uPSIxLjEiPjxjaXJjbGUgY3g9IjMwMCIgY3k9IjMwMCIgcj0iMzAwIiBmaWxsPSIjZjlhYThmIi8+PHBhdGggZD0ibTU1MS44IDM5OS43Yy0yMi40IDUzLjUtNjcgODAuMi0xMzMuNiA4MC4yLTEyLjIgMC0yNS41IDEuNS0zOS43IDQuNi0yMS40IDQuNi0zMi4xIDExLTMyLjEgMTkuMSAwIDIuNSAxLjggNS41IDUuMyA4LjggMy42IDMuMyA2LjYgNSA5LjIgNS0xMi43IDAtNC4xIDAuNCAyNiAxLjEgMzAuMSAwLjggNDguOSAxLjEgNTYuNSAxLjEtNDQuMyAyNi0xMTguNCAzNy45LTIyMi4zIDM1LjktMzQuMS0wLjUtNjMuNC0xNS41LTg3LjgtNDUuMS0yNC0yOC0zNS45LTU5LjMtMzUuOS05My45IDAtMzYuNiAxMi4zLTY3LjggMzcuMS05My42IDI0LjctMjUuNyA1NS40LTM4LjYgOTItMzguNiA4LjEgMCAxOSAxLjggMzIuNSA1LjMgMTMuNSAzLjYgMjIuNSA1LjMgMjcuMSA1LjMgMTguOCAwIDQyLjMtNy44IDcwLjMtMjMuMyAyOC0xNS41IDQxLjMtMjMuMyAzOS43LTIzLjMtNS4xIDUzLjUtMjIuOSA4OS40LTUzLjUgMTA3LjctMjEuOSAxMi43LTMyLjggMjUuMi0zMi44IDM3LjQgMCA3LjYgNC42IDEzLjggMTMuNyAxOC4zIDcuMSAzLjYgMTUgNS40IDIzLjcgNS40IDEzLjIgMCAyNi4yLTguMSAzOS0yNC40IDEyLjctMTYuMyAxOC4zLTMxLjEgMTYuOC00NC4zLTEuNS0xNS4zLTAuNS0zMy42IDMuMS01NSAxLTYuMSA0LjctMTMuNiAxMS4xLTIyLjUgNi40LTguOSAxMi4xLTE0LjQgMTcuMi0xNi40IDAgNC42LTEuNiAxMi4yLTUgMjIuOS0zLjMgMTAuNy01IDE4LjYtNSAyMy43IDAgMTEuMiAzIDE5LjkgOS4yIDI2IDkuMi0zLjYgMTcuMy0xNSAyNC40LTM0LjQgNi4xLTE0LjggOS43LTI5IDEwLjctNDIuOC0yMS40LTEtNDEuOS0xMC43LTYxLjUtMjktMTkuNi0xOC4zLTI5LjQtMzguMi0yOS40LTU5LjYgMC0zLjYgMC41LTcuMSAxLjUtMTAuNyAzIDQuNiA3LjYgMTEuNyAxMy43IDIxLjQgOC43IDEyLjcgMTUuMyAxOS4xIDE5LjkgMTkuMSA2LjEgMCA5LjItNi40IDkuMi0xOS4xIDAtMTYuMy00LjMtMzEuMS0xMy00NC4zLTkuNy0xNS44LTIyLjItMjMuNy0zNy40LTIzLjctNy4xIDAtMTcuOCAzLjgtMzIuMSAxMS41LTE0LjMgNy42LTI3LjMgMTEuNS0zOSAxMS41LTMuNiAwLTE5LjQtNC42LTQ3LjQtMTMuOCA0OS40LTguMSA3NC4xLTE1LjUgNzQuMS0yMi4xIDAtMTcuMy0zMy45LTI5LTEwMS42LTM1LjEtNi42LTAuNS0xOC44LTEuNS0zNi43LTMuMSAyLTIuNSAxNi41LTUuMyA0My41LTguNCAyMi45LTIuNSAzOS0zLjggNDguMS0zLjggMTIxLjIgMCAxOTguMSA1OC44IDIzMC43IDE3Ni41IDUuNi00LjYgOC40LTEyLjQgOC40LTIzLjIgMC0xMy45LTQuMS0zMS41LTEyLjItNTIuNy0zLjEtOC4yLTcuOS0yMC42LTE0LjUtMzcuMiA0MS43IDUzLjIgNjIuNiAxMDMuNiA2Mi42IDE1MS4yIDAgMjUuMS01LjkgNDcuOC0xNy42IDY4LjMtNy42IDEzLjgtMjEuOSAzMS41LTQyLjggNTMtMjAuOSAyMS41LTM1LjEgMzguMS00Mi44IDQ5LjkgMjgtNy42IDQ2LjQtMTMuNSA1NS0xNy42IDE5LjMtOC42IDM2LjktMjEuNiA1Mi43LTM5IDAgNi42LTIuOCAxNi42LTguNCAyOS44TTIxOC44IDk5LjVjMCA5LjItNS4xIDE1LTE1LjMgMTcuNmwtMTkuOSAzLjFjLTcuMSAzLjYtMTcuNiAxNy42LTMxLjMgNDItMS41LTcuNi0zLjgtMTguMy02LjktMzIuMS00LjYgMC41LTEyLjIgNC42LTIyLjkgMTIuMi00LjYgMy42LTEyIDguOS0yMi4yIDE2IDMuMS0xOC4zIDEzLjItMzYuOSAzMC42LTU1LjggMTguMy0yMC45IDM2LjItMzEuMyA1My41LTMxLjMgMjIuOSAwIDM0LjQgOS40IDM0LjQgMjguM20xMzIuOSA3MC4zYzAgOC43LTQuNyAxNS45LTE0LjEgMjEuOC05LjQgNS45LTE4LjcgOC44LTI3LjkgOC44LTEyLjIgMC0yMy4yLTYuOS0zMi44LTIwLjYtMTEuNy0xNi44LTIzLjctMjcuNy0zNS45LTMyLjkgMi41LTIuNSA1LjYtMy44IDkuMi0zLjggNC42IDAgMTIuMyAzLjYgMjMuMyAxMC43IDEwLjkgNy4xIDE3LjkgMTAuNyAyMSAxMC43IDIuNSAwIDYuNy0zLjYgMTIuNi0xMC43IDUuOS03LjEgMTIuMy0xMC43IDE5LjUtMTAuNyAxNi44IDAgMjUuMiA4LjkgMjUuMiAyNi43IiBmaWxsPSIjMjAwMDAwIi8+PC9zdmc+);
}
.G {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiB2ZXJzaW9uPSIxLjEiPjxjaXJjbGUgY3g9IjMwMCIgY3k9IjMwMCIgcj0iMzAwIiBmaWxsPSIjOWJkM2FlIi8+PHBhdGggZD0ibTU2Mi42IDMzNy40YzAgMTAtMy45IDE5LTExLjYgMjctNy43IDgtMTYuNiAxMi0yNi42IDEyLTE2IDAtMjcuNy03LjUtMzUuMi0yMi41bC0zNS4yLTEuNWMtNy41IDAtMjIuMyAzLjMtNDQuMiA5LjgtMjMuNSA2LjUtMzcgMTEuNy00MC41IDE1LjctNS41IDYtMTAgMjAtMTMuNSA0Mi0zIDE4LTQuNSAzMS4yLTQuNSAzOS43IDAgMTMuNSAyLjEgMjMuNCA2LjQgMjkuNiA0LjMgNi4yIDEzIDExLjUgMjYuMiAxNS43IDEzLjIgNC4yIDIxLjQgNi42IDI0LjQgNy4xIDIgMCA1LjItMC4yIDkuOC0wLjdsOSAwYzYuNSAwIDEzLjIgMSAyMC4yIDMgMTAgMyAxNC4zIDcgMTIuOCAxMi03LTEtMTkuMiAwLjUtMzYuNyA0LjVsMjEgMTAuNWMwIDYtOC41IDktMjUuNSA5LTQuNSAwLTEwLjYtMS0xOC40LTMtNy43LTItMTIuOS0zLTE1LjQtM2wtOS43IDBjLTAuNSA1LTIgMTIuNS00LjUgMjIuNS04LjUtMC41LTE4LjUtNS41LTMwLTE1LTExLjUtOS41LTE4LjctMTQuMi0yMS43LTE0LjItMyAwLTcuMyA0LjgtMTIuNyAxNC4yLTUuNSA5LjUtOC4yIDE2LTguMiAxOS41LTYuNS0zLjUtMTItMTAtMTYuNS0xOS41LTItNi41LTQuMi0xMy02LjctMTkuNS01IDAuNS0xNC4yIDExLTI3LjcgMzEuNWwtMy44IDBjLTEtMS41LTQuOC0xMi0xMS4yLTMxLjUtMTUuNS01LTMwLTcuNS00My41LTcuNS02LjUgMC0xNi41IDEuNS0zMCA0LjVsLTIxLTEuNWMzLTMgMTEuNy04LjcgMjYuMi0xNy4yIDE3LTEwIDMwLTE1IDM5LTE1IDEuNSAwIDMuNSAwLjMgNiAwLjggMi41IDAuNSA0LjUgMC44IDYgMC44IDMuNSAwIDkuMS0xLjkgMTYuOS01LjYgNy43LTMuNyAxMi4yLTcuMSAxMy41LTEwLjEgMS4zLTMgMS45LTEwLjggMS45LTIzLjIgMC0yOC41LTcuNS00OS43LTIyLjUtNjMuNy0xMy0xMi41LTM0LjUtMjEuNS02NC41LTI3LTggMjguNS0zMC41IDQyLjctNjcuNCA0Mi43LTEyIDAtMjQtNy4yLTM2LTIxLjdDNDQuNyAzNzMuOCAzOC43IDM2MC42IDM4LjcgMzQ4LjZjMC0xOC41IDcuNy0zMy43IDIzLjItNDUuNy0xMi41LTEzLTE4LjctMjYuMi0xOC43LTM5LjcgMC0xMi41IDMuOS0yMy41IDExLjYtMzMgNy43LTkuNSAxNy45LTE1IDMwLjQtMTYuNS0xLTE2IDQuMi0yNyAxNS43LTMzLTUuNS01LjUtOC4yLTE1LjItOC4yLTI5LjIgMC0xNi41IDUuNS0zMC4yIDE2LjUtNDEuMiAxMS0xMSAyNC43LTE2LjUgNDEuMi0xNi41IDE4IDAgMzIuNyA2LjMgNDQuMiAxOC44IDE0LjUtNDkuNSA0NS43LTc0LjIgOTMuNy03NC4yIDI1IDAgNDcgMTAgNjYgMzAgNyA3LjUgMTAuNSAxMS41IDEwLjUgMTItNiAwLTMtMS4xIDktMy40IDEyLTIuMiAyMC43LTMuNCAyNi4yLTMuNCAxOS41IDAgMzYuNyA3LjIgNTEuNyAyMS43IDEzIDEzIDIyIDI5LjUgMjcgNDkuNSAzLjUgMC41IDkgMiAxNi41IDQuNSAxMSA1LjUgMTYuNSAxNSAxNi41IDI4LjUgMCAyLjUtMiA3LjMtNiAxNC4yIDMyIDE4IDQ4IDQzIDQ4IDc1IDAgOS0zLjUgMjEuNS0xMC41IDM3LjUgMTMgNy41IDE5LjUgMTguNSAxOS41IDMzbS0zMDguOCAzMyAwLTkuN2MwLTExLjUtNS42LTIyLTE2LjktMzEuNS0xMS4yLTkuNS0yMi42LTE0LjItMzQuMS0xNC4yLTE0IDAtMjcgMy4yLTM5IDkuNyAyNi41LTEuNSA1Ni41IDEzLjggODkuOSA0NS43bS0xMy41LTkyLjljLTcuNS04LjUtMTQtMTcuMi0xOS41LTI2LjItMjEgNS41LTMxLjUgMTEuNy0zMS41IDE4LjcgNi0wLjUgMTQuNyAwLjYgMjYuMiAzLjQgMTEuNSAyLjggMTkuNyA0LjEgMjQuOCA0LjFtNDUuNy0yMy4yIDAtMzNjLTEyLTItMTkuMy0zLTIxLjctM2wwIDExLjIgMjEuNyAyNC43bTk3LjQtMjFjLTYtMi41LTE3LjItNy41LTMzLjctMTVsMCA2NC41YzIzLjUtMTMuNSAzNC43LTMwIDMzLjctNDkuNW00MS4yIDg4LjUtMTYuNS0yMC4yYy0xMCA3LTIwLjEgMTQuMS0zMC40IDIxLjQtMTAuMyA3LjItMTkuMSAxNS40LTI2LjYgMjQuNCAyMi41LTEyIDQ3LTIwLjUgNzMuNC0yNS41IiBmaWxsPSIjMDAxNjBiIi8+PC9zdmc+);
}
.C {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIj48Y2lyY2xlIGN4PSIzMDAiIGN5PSIzMDAiIHI9IjMwMCIgZmlsbD0iI2NjYzJjMCIvPjxwYXRoIGQ9Ik0zMDAgNjBBNTAwIDUwMCAwIDAgMCA1NDAgMzAwIDUwMCA1MDAgMCAwIDAgMzAwIDU0MCA1MDAgNTAwIDAgMCAwIDYwIDMwMCA1MDAgNTAwIDAgMCAwIDMwMCA2MG0wIDkwQTMwMCAzMDAgMCAwIDEgMTUwIDMwMCAzMDAgMzAwIDAgMCAxIDMwMCA0NTAgMzAwIDMwMCAwIDAgMSA0NTAgMzAwIDMwMCAzMDAgMCAwIDEgMzAwIDE1MCIgZmlsbD0iIzEzMGMwZSIvPjwvc3ZnPg==);
}

.mana_symbol_container {
	position: absolute;
	margin-top:-15px;
	margin-left:-15px;
	width:30px;
	height:30px;
}

.w_position {
	top:-50px;
	left:0px;
}

.u_position {
	top:-15px;
	left:48px;
}

.b_position {
	top:40px;
	left:29px;
}

.r_position {
	top:40px;
	left:-29px;
}

.g_position {
	top:-15px;
	left:-48px;
}

.c_position {
	top:0px;
	left:0px;
}

.wubrgc {
	position:relative;
	left: 50%;
	top:75px;
}

/*Hide the checkbox*/
.mana_symbol_container input {
    position: absolute;
    padding: 0px;
    margin: 0px;
    top: 0px;
    left: 0px;
    box-sizing: border-box;
	-moz-box-sizing: border-box;
	-webkit-box-sizing: border-box;
    height: 100%;
    width: 100%;
    opacity: 0;
    cursor: pointer;
}

.mana_symbol {
    position: absolute;
    top: 0px;
    left: 0px;
    padding: 0px;
    margin: 0px;
    height: 100%;
    width: 100%;
}

.mana_symbol_shader {
    position: absolute;
    top: 0px;
    left: 0px;
    padding: 0px;
    margin: 0px;
    height: 100%;
    width: 100%;
    pointer-events: none;
    background-color: rgba(50,50,50,0.8);
}

/* Show the mana symbol fully when checked */
.mana_symbol_container input:checked ~ .mana_symbol_shader {
    background-color: rgba(50,50,50,0);
}

/*.mana_symbol_container:hover input ~ .mana_symbol_shader {
    background-color: rgba(50,50,50,0.2);
}*/

.mana_symbol_container:active input ~ .mana_symbol_shader {
    background-color: rgba(50,50,50,0.9);
}

.rotated {
	-webkit-transform: rotate(90deg);
	-moz-transform: rotate(90deg);
	-o-transform: rotate(90deg);
	-ms-transform: rotate(90deg);
	transform: rotate(90deg);
}

.selected {
	border-style: dotted;
	border-color: white;
	border-width: 1px;
	margin-top:-1px;
	margin-left:-1px;
}

.sideboard {
	position: fixed;
	border: 1px solid rgb(0,0,0);
	width: 250px;
	right: 25px;
	top: 25px;
	bottom: 25px;
	background-color: rgba(255,255,255,0.4);
	box-shadow: 2px 2px 4px rgba(0,0,0,0.4)
	-moz-border-radius: 5px;
	-webkit-border-radius: 5px;
	visibility: hidden;
	overflow-y: scroll;
	overflow-x: hidden;
}

.sideboarded {
}

.green_selector {
	position: absolute;
	border-color: white;
	border-width: 1px;
	border-style: dashed;
	background: rgba(0,255,0,0.2);
}

.blue_selector {
	position: absolute;
	border-color: white;
	border-width: 1px;
	border-style: solid;
	background: rgba(0,0,255,0.2);
}

.invisible_selector {
	position: absolute;
	border-color: white;
	border-width: 0px;
	border-style: solid;
	background: transparent;
}

.label {
	pointer-events: none;
	position:absolute;
	text-align: center;
	text-decoration: none;
	font-size: 28px;
	font-family: sans-serif;
	color: rgb(255,255,255);
	top:200px;
	left:100px;
	width: 212px;
}

.playmat {
	height:100%;
	width:100%;
}

.left {
	left:0px;
}

.secondleft {
	left:104px;
}

.right {
	right:0px;
}

.dark_look {
	outline:none;
	height:40px;
	padding-left: 15px;
	padding-right:15px;
	padding-top: 0px;
	padding-bottom: 0px;

	background-color: rgb(50,50,50);
	text-align: center;
	font-family: sans-serif;
	border: none;

	color: rgb(255,255,255);
}

.dark_look:hover {
	background-color: rgb(70,70,70);
}

.dark_look_clickable {
	outline:none;
	height:40px;
	padding-left: 15px;
	padding-right:15px;
	padding-top: 0px;
	padding-bottom: 0px;

	background-color: rgb(50,50,50);
	text-align: center;
	font-family: sans-serif;
	border: none;

	color: rgb(255,255,255);
}

.dark_look_clickable:hover {
	background-color: rgb(70,70,70);
}

.dark_look_clickable:active {
	background-color: rgb(40,40,40);
}

.toolbar {
	list-style-type: none;
	margin: 0;
	padding: 0;
	top: 0;
	left: 0;
	overflow: hidden;
	background-color: #333;
}

li {
    float: left;
}

.toolbar li button, .dropbtn {
    display: inline-block;
}

.toolbar li.dropdown {
    display: inline-block;
}

.dropdown-content {
    display: none;
    position: absolute;
    width: 160px;
    z-index: 1;
}

.dropdown-content button {
	width: 160px;
    display: block;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
}

.dropdown-content input {
	width: 160px;
    display: block;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
}

.dropdown:hover .dropdown-content {
    display: block;
}

.dropright-content {
	position:absolute;
	margin-top:-40px;
	margin-left:160px;
	display: none;
}

.dropright:hover .dropright-content {
	display: inline;
}

.help_popup {
	position: fixed;
	display: none;
	overflow-y: scroll;
	background-color: rgb(50,50,50);
	color: rgb(255,255,255);
	font-family: sans-serif;
	font-size: 14px;
	left: 50%;
	top: 50%;
	width: 600px;
	height: 50%;
	margin-left: -300px;
	margin-top:-12.5%;
	box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
}

.help_popup header {
	text-align: center;
	font-size: 30px;
	padding:15px;
}

.help_popup p {
	padding-left:15px;
	padding-right:15px;
}

.card_info_popup {
	position: absolute;
	background-color: black;
	height: 495px;
	width: 312px;
	display: none;
	box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
}
.magnfied_card_view{
	width: 312px;
	height: 445px;
	border-spacing: 0px;
}
.card_popup_control_panel {
	width:312px;
	height: 50px;
}
.card_popup_control_panel_button {
	width: 104px;
	height: 50px;
	top: 445px;
	position:absolute;
}

.edit_card_width {
	width:185px;
	box-sizing:border-box;
}

.analyze_card_button {
	width: 185px;
	height: 50px;
	top: 445px;
	position:absolute;
}

.horizontal_bar {
	width: 185px;
	height: 5px;
	top: 440px;
	position:absolute;
	background-color: rgb(0,0,0);
}

.edit_card_control_panel {
	width:185px;
	height: 495px;
	margin: 0px;
	top: 0px;
	left: 312px;
	position: absolute;
	background-color:rgb(50,50,50);
	display: none;
	box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
}

.analyze_card_results {
	position: absolute;
	height: 264px;
	width: 497px;
	top: 495px;
	left: 0px;
	box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
	background-color:rgb(70,70,70);
	display: none;
}

.graph_title {
	position: absolute;
	height: 24px;
	width: 475px;
	top: 0px;
	left: 22px;
	font-size: 20px;
	text-align: center;
}

.vertical_axis_label {
	position: absolute;
	-webkit-transform: rotate(270deg);
	-moz-transform: rotate(270deg);
	-o-transform: rotate(270deg);
	-ms-transform: rotate(270deg);
	transform: rotate(270deg);
	height: 22px;
	width: 264px;
	top: 121px;
	left: -121px;
	font-size: 18px;
	text-align: center;
}

.horizontal_axis_label {
	position: absolute;
	height: 18px;
	width: 475px;
	bottom: 0px;
	left: 22px;
	font-size: 18px;
	text-align: center;
}

.vertical_axis {
	position: absolute;
	height: 222px;
	width: 3px;
	top: 24px;
	left: 22px;
	background-color:rgb(0,0,0);
}

.horizontal_axis {
	position: absolute;
	height: 3px;
	width: 470px;
	bottom: 36px;
	left: 25px;
	background-color:rgb(0,0,0);
}

.axis_marker {
	position: absolute;
	font-size: 18px;
	text-align: center;
	height: 18px;
	width: 25px;
	bottom: 18px;
	left: 26px;
}

.graph_bar {
	position: absolute;
	height: 200px;
	width: 25px;
	bottom: 39px;
	left: 26px;
	background-color:red;
}

.highlighted_graph_bar {
	position: absolute;
	height: 200px;
	width: 25px;
	bottom: 39px;
	left: 26px;
	background-color:red;
	box-sizing: border-box;
	-moz-box-sizing: border-box;
	-webkit-box-sizing: border-box;
	border: 2px solid rgb(0,0,0);
}

.graph_bar_label_outside {
	position: absolute;
	-webkit-transform: rotate(270deg);
	-moz-transform: rotate(270deg);
	-o-transform: rotate(270deg);
	-ms-transform: rotate(270deg);
	transform: rotate(270deg);
	height: 20px;
	width: 100px;
	top: -60px;
	left: -38px;
	text-align: left;
	font-size: 18px;
}

.graph_bar_label_inside {
	position: absolute;
	-webkit-transform: rotate(270deg);
	-moz-transform: rotate(270deg);
	-o-transform: rotate(270deg);
	-ms-transform: rotate(270deg);
	transform: rotate(270deg);
	height: 20px;
	width: 100px;
	top: 40px;
	left: -38px;
	text-align: right;
	font-size: 18px;
}

.card{
	width: 212px;
	height: 296px;
}

.draggable{
	position:absolute;
	cursor: move;
}

#counter_container {
	position:absolute;
	left:0;
	top:0;
}

#counter_template {
	display: none;
}

.counter {
	position: absolute;
	width: 60px;
	height: 60px;
	border-radius: 60px;
	box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
}

.counter .value {
	border: none;
	background: none;
	text-align: center;
	position: absolute;
	left:0;
	right:0;
	padding:22px;
}

.counter .btn {
	position: absolute;
	width: 22px;
	right: 0;
}

.counter .increment {
	top: 0;
}

.counter .decrement {
	bottom: 0;
}

	</style>
</head>
<body id="body">
	<ul class="toolbar">
		<li><input type="text" class="dark_look" id="cardimageurl" placeholder="Enter card image URL here" onclick="clearCardImageUrlEntry()"/></li>
		<li><button class="dark_look_clickable" onclick="addCard()">Add Card</button></li>
		<li><button class="dark_look_clickable" onclick="addCounter()">Add Counter</button></li>
		<li class="dropdown">
			<button class="dark_look" class="dropbtn">File</button>
			<div class="dropdown-content">
				<button class="dark_look_clickable" id="save button" onclick="saveDocument()" >Save</button>
				<div class="dropright">
					<button class="dark_look" >Name</button>
					<div class="dropright-content">
						<input id="deck name" type="text" class="dark_look" placeholder="MTG Deck"/>
					</div>
				</div>
				<div class="dropright">
					<button class="dark_look" >Card Sleeve Image</button>
					<div class="dropright-content">
						<input id="card sleeve image" type="text" class="dark_look" placeholder="URL" value="http://i.ebayimg.com/images/g/l9YAAOSweW5VX2or/s-l300.jpg"/>
					</div>
				</div>
			</div>
		</li>
		<li class="dropdown">
			<button class="dark_look" class="dropbtn">Game</button>
			<div class="dropdown-content">
				<button class="dark_look_clickable" onclick="newGame()">New Game</button>
				<button class="dark_look_clickable" onclick="mulligan()">Mulligan</button>
				<div class="dropright">
					<button class="dark_look" >Starting Life</button>
					<div class="dropright-content">
						<input id="starting life" type="number" class="dark_look" placeholder="20"/>
					</div>
				</div>
			</div>
		</li>
		<li class="dropdown">
			<button class="dark_look" class="dropbtn">Sort By</button>
			<div class="dropdown-content">
				<button class="dark_look_clickable" onclick="costSort()">Cost</button>
				<button class="dark_look_clickable" onclick="colorSort()">Color</button>
				<button class="dark_look_clickable" onclick="typeSort()">Type</button>
				<button class="dark_look_clickable" onclick="purposeSort()">Purpose</button>
				<button class="dark_look_clickable" onclick="curvabilitySort()">Curvability</button>
			</div>
		</li>
		<li class="dropdown">
			<button class="dark_look_clickable" class="dropbtn" onclick="toggleSideboard()">Sideboard</button>
			<div class="dropdown-content">
				<button id="toggle sideboard button" class="dark_look_clickable" onclick="toggleSideboard()">Show Sideboard</button>
				<button class="dark_look_clickable" onclick="dumpSideboard()">Dump Sideboard</button>
			</div>
		</li>
		<li class="dropdown">
			<button class="dark_look" class="dropbtn">Selection</button>
			<div class="dropdown-content">
				<button class="dark_look_clickable" onclick="stack()">Stack</button>
				<button class="dark_look_clickable" onclick="shuffle()">Shuffle</button>
				<div class="dropright">
					<button class="dark_look" >Delete</button>
					<div class="dropright-content">
						<button class="dark_look_clickable" onclick="deleteSelection()">Confirm</button>
					</div>
				</div>
				<button class="dark_look_clickable" onclick="selectAll()">Select All</button>
			</div>
		</li>
		<li class="dropdown">
			<button class="dark_look" class="dropbtn">Help</button>
			<div class="dropdown-content">
				<button class="dark_look_clickable" onclick="toggleAddingCardsHelp()">Adding Cards</button>
				<button class="dark_look_clickable" onclick="toggleUserInterfaceHelp()">User Interface</button>
				<button class="dark_look_clickable" onclick="toggleAnalysisHelp()">Analysis</button>
			</div>
		</li>
	</ul>

	<div id="playmat" class="playmat">
	<div class="label" style="left: 0px; top: 71px;">Total: 100</div><div class="label" style="top: 141px; left: 50px;">Land</div><img src="http://magiccards.info/scans/en/avr/226.jpg" class="draggable card" name="Cavern of Souls" purpose="Protection" front="http://magiccards.info/scans/en/avr/226.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="32" style="top: 171px; left: 50px;"><img src="http://magiccards.info/scans/en/ts/274.jpg" class="draggable card" name="Gemstone Caverns" purpose="Ramp" front="http://magiccards.info/scans/en/ts/274.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="32" style="top: 200px; left: 50px;"><img src="http://magiccards.info/scans/en/ema/248.jpg" class="draggable card" name="Wasteland" purpose="" front="http://magiccards.info/scans/en/ema/248.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="32" style="top: 229px; left: 50px;"><img src="http://magiccards.info/scans/en/ts/272.jpg" class="draggable card" name="Flagstones of Trokair" purpose="" front="http://magiccards.info/scans/en/ts/272.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 258px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 287px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 316px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 345px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 374px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 403px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 432px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 461px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/232.jpg" class="draggable card" name="Plains" purpose="" front="http://magiccards.info/scans/en/zen/232.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="1" style="top: 490px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 519px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 548px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 577px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 606px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 635px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 664px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 693px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 722px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 751px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 780px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 809px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 838px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/236.jpg" class="draggable card" name="Island" purpose="" front="http://magiccards.info/scans/en/zen/236.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 867px; left: 50px;"><img src="http://magiccards.info/scans/en/ddf/74.jpg" class="draggable card" name="Seat of the Synod" purpose="" front="http://magiccards.info/scans/en/ddf/74.jpg" back="" land="true" creature="false" planeswalker="false" artifact="true" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="2" style="top: 896px; left: 50px;"><img src="http://magiccards.info/scans/en/10e/347.jpg" class="draggable card" name="Adarkar Wastes" purpose="" front="http://magiccards.info/scans/en/10e/347.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 925px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/211.jpg" class="draggable card" name="Arid Mesa" purpose="" front="http://magiccards.info/scans/en/zen/211.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 954px; left: 50px;"><img src="http://magiccards.info/scans/en/mma/221.jpg" class="draggable card" name="City of Brass" purpose="" front="http://magiccards.info/scans/en/mma/221.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 983px; left: 50px;"><img src="http://magiccards.info/scans/en/cmd/269.jpg" class="draggable card" name="Command Tower" purpose="" front="http://magiccards.info/scans/en/cmd/269.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1012px; left: 50px;"><img src="http://magiccards.info/scans/en/ktk/233.jpg" class="draggable card" name="Flooded Strand" purpose="" front="http://magiccards.info/scans/en/ktk/233.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1041px; left: 50px;"><img src="http://magiccards.info/scans/en/m13/225.jpg" class="draggable card" name="Glacial Fortress" purpose="" front="http://magiccards.info/scans/en/m13/225.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1070px; left: 50px;"><img src="http://magiccards.info/scans/en/di/174.jpg" class="draggable card" name="Hallowed Fountain" purpose="" front="http://magiccards.info/scans/en/di/174.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1099px; left: 50px;"><img src="http://magiccards.info/scans/en/jou/163.jpg" class="draggable card" name="Mana Confluence" purpose="" front="http://magiccards.info/scans/en/jou/163.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1128px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/219.jpg" class="draggable card" name="Marsh Flats" purpose="" front="http://magiccards.info/scans/en/zen/219.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1157px; left: 50px;"><img src="http://magiccards.info/scans/en/ktk/239.jpg" class="draggable card" name="Polluted Delta" purpose="" front="http://magiccards.info/scans/en/ktk/239.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1186px; left: 50px;"><img src="http://magiccards.info/scans/en/zen/223.jpg" class="draggable card" name="Scalding Tarn" purpose="" front="http://magiccards.info/scans/en/zen/223.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1215px; left: 50px;"><img src="http://magiccards.info/scans/en/som/229.jpg" class="draggable card" name="Seachrome Coast" purpose="" front="http://magiccards.info/scans/en/som/229.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1244px; left: 50px;"><img src="http://magiccards.info/scans/en/vma/322.jpg" class="draggable card" name="Tundra" purpose="" front="http://magiccards.info/scans/en/vma/322.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1273px; left: 50px;"><img src="http://magiccards.info/scans/en/ktk/248.jpg" class="draggable card" name="Windswept Heath" purpose="" front="http://magiccards.info/scans/en/ktk/248.jpg" back="" land="true" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="" commander="false" mana_production_bitvector="3" style="top: 1302px; left: 50px;"><div class="label" style="top: 111px; left: 50px;">40</div><div class="label" style="top: 141px; left: 272px;">0 Mana</div><img src="http://magiccards.info/scans/en/gpx/3.jpg" class="draggable card" name="Chrome Mox" purpose="Ramp" front="http://magiccards.info/scans/en/gpx/3.jpg" back="" land="false" creature="false" planeswalker="false" artifact="true" enchantment="false" sorcery="false" instant="false" casting_cost="0" commander="false" mana_production_bitvector="0" style="top: 171px; left: 272px;"><img src="http://magiccards.info/scans/en/jvc/23.jpg" class="draggable card" name="Daze" purpose="Counter" front="http://magiccards.info/scans/en/jvc/23.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="0" commander="false" mana_production_bitvector="0" style="top: 200px; left: 272px;"><img src="http://magiccards.info/scans/en/ema/49.jpg" class="draggable card" name="Force of Will" purpose="Counter" front="http://magiccards.info/scans/en/ema/49.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="0" commander="false" mana_production_bitvector="0" style="top: 229px; left: 272px;"><img src="http://magiccards.info/scans/en/fnmp/151.jpg" class="draggable card" name="Gitaxian Probe" purpose="Information" front="http://magiccards.info/scans/en/fnmp/151.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="0" commander="false" mana_production_bitvector="0" style="top: 258px; left: 272px;"><img src="http://magiccards.info/scans/en/nph/38.jpg" class="draggable card" name="Mental Misstep" purpose="Counter" front="http://magiccards.info/scans/en/nph/38.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="0" commander="false" mana_production_bitvector="0" style="top: 287px; left: 272px;"><img src="http://magiccards.info/scans/en/fvr/10.jpg" class="draggable card" name="Mox Diamond" purpose="Ramp" front="http://magiccards.info/scans/en/fvr/10.jpg" back="" land="false" creature="false" planeswalker="false" artifact="true" enchantment="false" sorcery="false" instant="false" casting_cost="0" commander="false" mana_production_bitvector="0" style="top: 316px; left: 272px;"><div class="label" style="top: 111px; left: 272px;">6</div><div class="label" style="top: 141px; left: 494px;">1 Mana</div><img src="http://magiccards.info/scans/en/ema/9.jpg" class="draggable card" name="Enlightened Tutor" purpose="Card Selection" front="http://magiccards.info/scans/en/ema/9.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 171px; left: 494px;"><img src="http://magiccards.info/scans/en/pc/25.jpg" class="draggable card" name="Mana Tithe" purpose="Counter" front="http://magiccards.info/scans/en/pc/25.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 200px; left: 494px;"><img src="http://magiccards.info/scans/en/ddo/20.jpg" class="draggable card" name="Mother of Runes" purpose="Protection" front="http://magiccards.info/scans/en/ddo/20.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 229px; left: 494px;"><img src="http://magiccards.info/scans/en/ddp/7.jpg" class="draggable card" name="Oust" purpose="Removal" front="http://magiccards.info/scans/en/ddp/7.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 258px; left: 494px;"><img src="http://magiccards.info/scans/en/5dn/19.jpg" class="draggable card" name="Steelshaper's Gift" purpose="Protection" front="http://magiccards.info/scans/en/5dn/19.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 287px; left: 494px;"><img src="http://magiccards.info/scans/en/pc/31.jpg" class="draggable card" name="Sunlance" purpose="Removal" front="http://magiccards.info/scans/en/pc/31.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 316px; left: 494px;"><img src="http://magiccards.info/scans/en/ddf/22.jpg" class="draggable card" name="Swords to Plowshares" purpose="Removal" front="http://magiccards.info/scans/en/ddf/22.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 345px; left: 494px;"><img src="http://magiccards.info/scans/en/vi/123.jpg" class="draggable card" name="Tithe" purpose="Card Selection" front="http://magiccards.info/scans/en/vi/123.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="W" commander="false" mana_production_bitvector="0" style="top: 374px; left: 494px;"><img src="http://magiccards.info/scans/en/ts/48.jpg" class="draggable card" name="Ancestral Vision" purpose="Card Selection" front="http://magiccards.info/scans/en/ts/48.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 403px; left: 494px;"><img src="http://magiccards.info/scans/en/cmd/40.jpg" class="draggable card" name="Brainstorm" purpose="Card Selection" front="http://magiccards.info/scans/en/cmd/40.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 432px; left: 494px;"><img src="http://magiccards.info/scans/en/in/51.jpg" class="draggable card" name="Disrupt" purpose="Counter" front="http://magiccards.info/scans/en/in/51.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 461px; left: 494px;"><img src="http://magiccards.info/scans/en/fnmp/91.jpg" class="draggable card" name="Force Spike" purpose="Counter" front="http://magiccards.info/scans/en/fnmp/91.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 490px; left: 494px;"><img src="http://magiccards.info/scans/en/ema/55.jpg" class="draggable card" name="Hydroblast" purpose="Counter" front="http://magiccards.info/scans/en/ema/55.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" token="false" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 519px; left: 494px;"><img src="http://magiccards.info/scans/en/m10/68.jpg" class="draggable card" name="Ponder" purpose="Card Selection" front="http://magiccards.info/scans/en/m10/68.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 548px; left: 494px;"><img src="http://magiccards.info/scans/en/m11/70.jpg" class="draggable card" name="Preordain" purpose="Card Selection" front="http://magiccards.info/scans/en/m11/70.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 577px; left: 494px;"><img src="http://magiccards.info/scans/en/cn2/120.jpg" class="draggable card" name="Serum Visions" purpose="Card Selection" front="http://magiccards.info/scans/en/cn2/120.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 606px; left: 494px;"><img src="http://magiccards.info/scans/en/zen/67.jpg" class="draggable card" name="Spell Pierce" purpose="Counter" front="http://magiccards.info/scans/en/zen/67.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 635px; left: 494px;"><img src="http://magiccards.info/scans/en/mma/64.jpg" class="draggable card" name="Spell Snare" purpose="Counter" front="http://magiccards.info/scans/en/mma/64.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 664px; left: 494px;"><img src="http://magiccards.info/scans/en/cns/108.jpg" class="draggable card" name="Stifle" purpose="Stifle" front="http://magiccards.info/scans/en/cns/108.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="U" commander="false" mana_production_bitvector="0" style="top: 693px; left: 494px;"><div class="label" style="top: 111px; left: 494px;">19</div><div class="label" style="top: 141px; left: 716px;">2 Mana</div><img src="http://magiccards.info/scans/en/v16/14.jpg" class="draggable card" name="Umezawa's Jitte" purpose="Beats" front="http://magiccards.info/scans/en/v16/14.jpg" back="" land="false" creature="false" planeswalker="false" artifact="true" enchantment="false" sorcery="false" instant="false" casting_cost="2" commander="false" mana_production_bitvector="0" style="top: 171px; left: 716px;"><img src="http://magiccards.info/scans/en/mm2/11.jpg" class="draggable card" name="Celestial Purge" purpose="Removal" front="http://magiccards.info/scans/en/mm2/11.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="1W" commander="false" mana_production_bitvector="0" style="top: 200px; left: 716px;"><img src="http://magiccards.info/scans/en/m14/22.jpg" class="draggable card" name="Imposing Sovereign" purpose="Removal" front="http://magiccards.info/scans/en/m14/22.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1W" commander="false" mana_production_bitvector="0" style="top: 229px; left: 716px;"><img src="http://magiccards.info/scans/en/zen/14.jpg" class="draggable card" name="Journey to Nowhere" purpose="Removal" front="http://magiccards.info/scans/en/zen/14.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="true" sorcery="false" instant="false" casting_cost="1W" commander="false" mana_production_bitvector="0" style="top: 258px; left: 716px;"><img src="http://magiccards.info/scans/en/ori/21.jpg" class="draggable card" name="Knight of the White Orchid" purpose="Ramp" front="http://magiccards.info/scans/en/ori/21.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="WW" commander="false" mana_production_bitvector="0" style="top: 287px; left: 716px;"><img src="http://magiccards.info/scans/en/wwk/20.jpg" class="draggable card" name="Stoneforge Mystic" purpose="Protection" front="http://magiccards.info/scans/en/wwk/20.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1W" commander="false" mana_production_bitvector="0" style="top: 316px; left: 716px;"><img src="http://magiccards.info/scans/en/fnmp/179.jpg" class="draggable card" name="Suspension Field" purpose="Removal" front="http://magiccards.info/scans/en/fnmp/179.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="true" sorcery="false" instant="false" casting_cost="1W" commander="false" mana_production_bitvector="0" style="top: 345px; left: 716px;"><img src="http://magiccards.info/scans/en/ema/33.jpg" class="draggable card" name="Unexpectedly Absent" purpose="Removal" front="http://magiccards.info/scans/en/ema/33.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="WW" commander="false" mana_production_bitvector="0" style="top: 374px; left: 716px;"><img src="http://magiccards.info/scans/en/jvc/24.jpg" class="draggable card" name="Counterspell" purpose="Counter" front="http://magiccards.info/scans/en/jvc/24.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="UU" commander="false" mana_production_bitvector="0" style="top: 403px; left: 716px;"><img src="http://magiccards.info/scans/en/fut/35.jpg" class="draggable card" name="Delay" purpose="Counter" front="http://magiccards.info/scans/en/fut/35.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 432px; left: 716px;"><img src="http://magiccards.info/scans/en/ori/60a.jpg" class="draggable card" name="Jace, Vryn's Prodigy" purpose="Card Selection" front="http://magiccards.info/scans/en/ori/60a.jpg" back="http://magiccards.info/scans/en/ori/60b.jpg" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 461px; left: 716px;"><img src="http://magiccards.info/scans/en/ts/66.jpg" class="draggable card" name="Looter il-Kor" purpose="Card Selection" front="http://magiccards.info/scans/en/ts/66.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 490px; left: 716px;"><img src="http://magiccards.info/scans/en/m11/62.jpg" class="draggable card" name="Mana Leak" purpose="Counter" front="http://magiccards.info/scans/en/m11/62.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 519px; left: 716px;"><img src="http://magiccards.info/scans/en/ddm/24.jpg" class="draggable card" name="Memory Lapse" purpose="Counter" front="http://magiccards.info/scans/en/ddm/24.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 548px; left: 716px;"><img src="http://magiccards.info/scans/en/ul/36.jpg" class="draggable card" name="Miscalculation" purpose="Counter" front="http://magiccards.info/scans/en/ul/36.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 577px; left: 716px;"><img src="http://magiccards.info/scans/en/soi/81.jpg" class="draggable card" name="Rattlechains" purpose="Beats" front="http://magiccards.info/scans/en/soi/81.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 606px; left: 716px;"><img src="http://magiccards.info/scans/en/rav/63.jpg" class="draggable card" name="Remand" purpose="Counter" front="http://magiccards.info/scans/en/rav/63.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 635px; left: 716px;"><img src="http://magiccards.info/scans/en/isd/78.jpg" class="draggable card" name="Snapcaster Mage" purpose="Card Selection" front="http://magiccards.info/scans/en/isd/78.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 664px; left: 716px;"><img src="http://magiccards.info/scans/en/10e/111.jpg" class="draggable card" name="Spiketail Hatchling" purpose="Counter" front="http://magiccards.info/scans/en/10e/111.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 693px; left: 716px;"><img src="http://magiccards.info/scans/en/ts/88.jpg" class="draggable card" name="Trickbind" purpose="Stifle" front="http://magiccards.info/scans/en/ts/88.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="true" casting_cost="1U" commander="false" mana_production_bitvector="0" style="top: 722px; left: 716px;"><img src="http://magiccards.info/scans/en/jr/26.jpg" class="draggable card" name="Meddling Mage" purpose="Counter" front="http://magiccards.info/scans/en/jr/26.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="WU" commander="false" mana_production_bitvector="0" style="top: 751px; left: 716px;"><div class="label" style="top: 111px; left: 716px;">21</div><div class="label" style="top: 141px; left: 938px;">3 Mana</div><img src="http://magiccards.info/scans/en/mpskld/28.jpg" class="draggable card" name="Sword of Feast and Famine" purpose="Protection" front="http://magiccards.info/scans/en/mpskld/28.jpg" back="" land="false" creature="false" planeswalker="false" artifact="true" enchantment="false" sorcery="false" instant="false" casting_cost="3" commander="false" mana_production_bitvector="0" style="top: 171px; left: 938px;"><img src="http://magiccards.info/scans/en/mpskld/29.jpg" class="draggable card" name="Sword of Fire and Ice" purpose="Protection" front="http://magiccards.info/scans/en/mpskld/29.jpg" back="" land="false" creature="false" planeswalker="false" artifact="true" enchantment="false" sorcery="false" instant="false" casting_cost="3" commander="false" mana_production_bitvector="0" style="top: 200px; left: 938px;"><img src="http://magiccards.info/scans/en/cns/16.jpg" class="draggable card" name="Council's Judgment" purpose="Removal" front="http://magiccards.info/scans/en/cns/16.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="1WW" commander="false" mana_production_bitvector="0" style="top: 229px; left: 938px;"><img src="http://magiccards.info/scans/en/ddg/34.jpg" class="draggable card" name="Oblivion Ring" purpose="Removal" front="http://magiccards.info/scans/en/ddg/34.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="true" sorcery="false" instant="false" casting_cost="2W" commander="false" mana_production_bitvector="0" style="top: 258px; left: 938px;"><img src="http://magiccards.info/scans/en/mt/55.jpg" class="draggable card" name="Vendilion Clique" purpose="Beats" front="http://magiccards.info/scans/en/mt/55.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1UU" commander="false" mana_production_bitvector="0" style="top: 287px; left: 938px;"><img src="http://magiccards.info/scans/en/rtr/155.jpg" class="draggable card" name="Detention Sphere" purpose="Removal" front="http://magiccards.info/scans/en/rtr/155.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="true" sorcery="false" instant="false" casting_cost="1WU" commander="false" mana_production_bitvector="0" style="top: 316px; left: 938px;"><img src="http://magiccards.info/scans/en/wmcq/2.jpg" class="draggable card" name="Geist of Saint Traft" purpose="Beats" front="http://magiccards.info/scans/en/wmcq/2.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1WU" commander="true" mana_production_bitvector="0" style="top: 345px; left: 938px;"><img src="http://magiccards.info/scans/en/ogw/157.jpg" class="draggable card" name="Reflector Mage" purpose="Removal" front="http://magiccards.info/scans/en/ogw/157.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1WU" commander="false" mana_production_bitvector="0" style="top: 374px; left: 938px;"><img src="http://magiccards.info/scans/en/emn/189.jpg" class="draggable card" name="Spell Queller" purpose="Counter" front="http://magiccards.info/scans/en/emn/189.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="1WU" commander="false" mana_production_bitvector="0" style="top: 403px; left: 938px;"><div class="label" style="top: 111px; left: 938px;">9</div><div class="label" style="top: 141px; left: 1160px;">4 Mana</div><img src="http://magiccards.info/scans/en/v14/1.jpg" class="draggable card" name="Armageddon" purpose="MLD" front="http://magiccards.info/scans/en/v14/1.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="3W" commander="false" mana_production_bitvector="0" style="top: 171px; left: 1160px;"><img src="http://magiccards.info/scans/en/v14/3.jpg" class="draggable card" name="Cataclysm" purpose="MLD" front="http://magiccards.info/scans/en/v14/3.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="false" sorcery="true" instant="false" casting_cost="2WW" commander="false" mana_production_bitvector="0" style="top: 200px; left: 1160px;"><img src="http://magiccards.info/scans/en/ala/9.jpg" class="draggable card" name="Elspeth, Knight-Errant" purpose="Protection" front="http://magiccards.info/scans/en/ala/9.jpg" back="" land="false" creature="false" planeswalker="true" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="2WW" commander="false" mana_production_bitvector="0" style="top: 229px; left: 1160px;"><img src="http://magiccards.info/scans/en/ne/17.jpg" class="draggable card" name="Parallax Wave" purpose="Removal" front="http://magiccards.info/scans/en/ne/17.jpg" back="" land="false" creature="false" planeswalker="false" artifact="false" enchantment="true" sorcery="false" instant="false" casting_cost="2WW" commander="false" mana_production_bitvector="0" style="top: 258px; left: 1160px;"><img src="http://magiccards.info/scans/en/ema/57.jpg" class="draggable card" name="Jace, the Mind Sculptor" purpose="Removal" front="http://magiccards.info/scans/en/ema/57.jpg" back="" land="false" creature="false" planeswalker="true" artifact="false" enchantment="false" sorcery="false" instant="false" casting_cost="2UU" commander="false" mana_production_bitvector="0" style="top: 287px; left: 1160px;"><div class="label" style="top: 111px; left: 1160px;">5</div><div class="label" style="top: 141px; left: 1382px;">Token</div><img src="http://magiccards.info/extras/token/magic-origins/angel.jpg" class="draggable card" name="Angel" purpose="" front="http://magiccards.info/extras/token/magic-origins/angel.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" token="true" casting_cost="" commander="false" mana_production_bitvector="0" style="top: 171px; left: 1382px;"><img src="http://magiccards.info/extras/token/magic-origins/angel.jpg" class="draggable card" name="Angel" purpose="" front="http://magiccards.info/extras/token/magic-origins/angel.jpg" back="" land="false" creature="true" planeswalker="false" artifact="false" enchantment="false" sorcery="false" instant="false" token="true" casting_cost="" commander="false" mana_production_bitvector="0" style="top: 200px; left: 1382px;"><div class="label" style="top: 111px; left: 1382px;">2</div></div>

	<div id="selector" class="invisible_selector">
	</div>

	<div id="sideboard" class="sideboard">
	</div>

	<div id="card info popup" class="card_info_popup">
		<img id="magnified card view" class="magnfied_card_view" src=""/>
		<div id="card info control panel" class="card_popup_control_panel">
			<button class="dark_look_clickable bottom left card_popup_control_panel_button" onclick="deleteCard()">Delete</button>
			<button class="dark_look_clickable bottom secondleft card_popup_control_panel_button" onclick="copyCard()">Copy</button>
			<button class="dark_look_clickable bottom right card_popup_control_panel_button" onclick="toggleEditCard()">Edit</button>
		</div>
		<div id="edit card control panel" class="edit_card_control_panel">
			<input type="text" id="card name input" class="dark_look edit_card_width" placeholder="Card Name" /><br>
			<input type="text" id="purpose input" class="dark_look edit_card_width" placeholder="Purpose" /><br>
			<input type="text" class="dark_look edit_card_width" id="card back input" placeholder="Transformed Image URL" /><br>
			<select id="card type" class="dark_look edit_card_width">
				<option value="land">Land</option>
				<option value="creature">Creature</option>
				<option value="planeswalker">Planeswalker</option>
				<option value="artifact">Artifact</option>
				<option value="enchantment">Enchantment</option>
				<option value="sorcery">Sorcery</option>
				<option value="instant">Instant</option>
				<option value="token">Token</option>
			</select>
			<div id="permanent menu">
				<select id="commander selection" class="dark_look edit_card_width">
					<option value=""></option>
					<option value="commander">Commander</option>
				</select>
				<!--&nbsp<label><input type="checkbox" id="commander checkbox" />Commander</label><br>-->
			</div>
			
			<!--&nbsp<label><input type="checkbox" id="land checkbox" />Land</label><br>
			&nbsp<label><input type="checkbox" id="creature checkbox" />Creature</label><br>
			&nbsp<label><input type="checkbox" id="planeswalker checkbox" />Planeswalker</label><br>
			&nbsp<label><input type="checkbox" id="artifact checkbox" />Artifact</label><br>
			&nbsp<label><input type="checkbox" id="enchantment checkbox" />Enchantment</label><br>
			&nbsp<label><input type="checkbox" id="sorcery checkbox" />Sorcery</label><br>
			&nbsp<label><input type="checkbox" id="instant checkbox" />Instant</label><br>
			&nbsp<label><input type="checkbox" id="token checkbox" />Token</label><br>-->
			<div id="land menu">
				<div class="wubrgc">
					<div class="mana_symbol_container w_position">
						<span class="mana_symbol W"></span>
						<input type="checkbox" id="produces white checkbox"/>
						<span class="mana_symbol_shader"></span>
					</div>
					<div class="mana_symbol_container u_position">
						<span class="mana_symbol U"></span>
						<input type="checkbox" id="produces blue checkbox"/>
						<span class="mana_symbol_shader"></span>
					</div>
					<div class="mana_symbol_container b_position">
						<span class="mana_symbol B"></span>
						<input type="checkbox" id="produces black checkbox"/>
						<span class="mana_symbol_shader"></span>
					</div>
					<div class="mana_symbol_container r_position">
						<span class="mana_symbol R"></span>
						<input type="checkbox" id="produces red checkbox"/>
						<span class="mana_symbol_shader"></span>
					</div>
					<div class="mana_symbol_container g_position">
						<span class="mana_symbol G"></span>
						<input type="checkbox" id="produces green checkbox"/>
						<span class="mana_symbol_shader"></span>
					</div>
					<div class="mana_symbol_container c_position">
						<span class="mana_symbol C"></span>
						<input type="checkbox" id="produces colorless checkbox"/>
						<span class="mana_symbol_shader"></span>
					</div>
				</div>
				
				<!--&nbspMana Production:<br>
				&nbsp<label><input type="checkbox" id="produces white checkbox" />W</label>
				<label><input type="checkbox" id="produces blue checkbox" />U</label>
				<label><input type="checkbox" id="produces black checkbox" />B</label><br>
				&nbsp<label><input type="checkbox" id="produces red checkbox" />R</label>
				<label><input type="checkbox" id="produces green checkbox" />G</label>
				<label><input type="checkbox" id="produces colorless checkbox" />C</label><br>-->
			</div>
			<div id="nonland menu">
				<input type="text" class="dark_look edit_card_width" id="casting cost input" placeholder="Mana Cost"/><br>
				<button class="dark_look_clickable bottom analyze_card_button" onclick="analyzeCard()">Analyze</button>
			</div>
		</div>
		<div id="analyze card results" class="analyze_card_results">
			<div id="graph title" class="graph_title">Probability you can cast this card</div>
			<div id="vertical axis label" class="vertical_axis_label">% Chance of having the right lands</div>
			<div id="horizontal axis label" class="horizontal_axis_label">Number of cards drawn from deck</div>
			<div id="vertical axis" class="vertical_axis"></div>
			<div id="horizontal axis" class="horizontal_axis"></div>
			<div id="axis 0 marker" class="axis_marker" style="left:26px">0</div>
			<div id="axis 1 marker" class="axis_marker" style="left:52px">1</div>
			<div id="axis 2 marker" class="axis_marker" style="left:78px">2</div>
			<div id="axis 3 marker" class="axis_marker" style="left:104px">3</div>
			<div id="axis 4 marker" class="axis_marker" style="left:130px">4</div>
			<div id="axis 5 marker" class="axis_marker" style="left:156px">5</div>
			<div id="axis 6 marker" class="axis_marker" style="left:182px">6</div>
			<div id="axis 7 marker" class="axis_marker" style="left:208px">7</div>
			<div id="axis 8 marker" class="axis_marker" style="left:234px">8</div>
			<div id="axis 9 marker" class="axis_marker" style="left:260px">9</div>
			<div id="axis 10 marker" class="axis_marker" style="left:286px">10</div>
			<div id="axis 11 marker" class="axis_marker" style="left:312px">11</div>
			<div id="axis 12 marker" class="axis_marker" style="left:338px">12</div>
			<div id="axis 13 marker" class="axis_marker" style="left:364px">13</div>
			<div id="axis 14 marker" class="axis_marker" style="left:390px">14</div>
			<div id="axis 15 marker" class="axis_marker" style="left:416px">15</div>
			<div id="axis 16 marker" class="axis_marker" style="left:442px">16</div>
			<div id="axis 17 marker" class="axis_marker" style="left:468px">17</div>
			<div id="graph 0 bar" class="graph_bar" style="left:26px"><div id="graph 0 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 1 bar" class="graph_bar" style="left:52px"><div id="graph 1 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 2 bar" class="graph_bar" style="left:78px"><div id="graph 2 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 3 bar" class="graph_bar" style="left:104px"><div id="graph 3 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 4 bar" class="graph_bar" style="left:130px"><div id="graph 4 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 5 bar" class="graph_bar" style="left:156px"><div id="graph 5 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 6 bar" class="graph_bar" style="left:182px"><div id="graph 6 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 7 bar" class="graph_bar" style="left:208px"><div id="graph 7 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 8 bar" class="graph_bar" style="left:234px"><div id="graph 8 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 9 bar" class="graph_bar" style="left:260px"><div id="graph 9 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 10 bar" class="graph_bar" style="left:286px"><div id="graph 10 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 11 bar" class="graph_bar" style="left:312px"><div id="graph 11 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 12 bar" class="graph_bar" style="left:338px"><div id="graph 12 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 13 bar" class="graph_bar" style="left:364px"><div id="graph 13 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 14 bar" class="graph_bar" style="left:390px"><div id="graph 14 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 15 bar" class="graph_bar" style="left:416px"><div id="graph 15 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 16 bar" class="graph_bar" style="left:442px"><div id="graph 16 bar label" class="graph_bar_label_outside"></div></div>
			<div id="graph 17 bar" class="graph_bar" style="left:468px"><div id="graph 17 bar label" class="graph_bar_label_outside"></div></div>
		</div>
	</div>
	
	<!-- whitespace in the counter will mess it up because whitespace/text is considered a child node -->
	<div id="counter_container" numcounters="0">
		<div class="counter draggable" id="counter_template"><div class="value" onmousedown="dragCounter()">1</div><button class="increment btn" onclick="incrementCounter()">+</button><button class="decrement btn" onclick="decrementCounter()">-</button></div>
	</div>

	<div id="adding cards help" class="help_popup">
		<header>Adding Cards</header>
		<p>To add a card, you first need to get a link to the card image. Go to <a href="https://magiccards.info/" target="_blank" style="color:red">magiccards.info</a> or <a href=" http://gatherer.wizards.com" target="_blank" style="color:red">gatherer.wizards.com</a> or whatever your favorite card search website is and search for the card you want to add. Next, right-click on the image, and click "Copy image address". Go back to this page, and click on the input box in the top left that says "Enter card image URL here" and press Ctrl-V to paste the image URL you copied. Finally, click the "Add Card" button just to the right of the input box to add the card.</p>
		<p>Next you need to input some information about the card. Move your mouse over the card and hover there for 2 seconds until the card magnifies. Click the "Edit" button below the magnified card to reveal more inputs for the card. You can type the card name and purpose, but these are only used to help sort the cards. There is also an input for the image URL to the transformed side. Next, select the card type from the drop down menu, and if it's a permanent, you can make it your commander.</p>
		<p>If the card is a land, you'll see additional clickable icons for the colors of mana you could use the land to produce if you were to play it. For example, a fetchland may be able to produce many colors of mana if your deck has the correct fetchable dual lands.</p>
		<p>If the card is castable, you'll see an input for the casting cost. This is also used for the analysis, and you should use the casting cost you will most likely pay for the spell in case the card has X in its mana cost, or has alternate casting costs. Type out a number representing the amount of generic mana required, then type W U B R G C for each white, blue, black, red, green, and colorless mana respectively required. Hybrid color mana can be input as {B/G}, but make sure you get the order of the colors correct (not {G/B}). The analysis does not currently support hybrid generic and colored, like {2/G}, so you'll need to enter that as either 2 or G. Here are some examples:</p>
		<table style="padding: 0px 15px 0px 15px">
			<tr><th>Card Name</th><th>Casting Cost</th></tr>
			<tr><td>Autochthon Wurm</td><td>10GGGWW</td></tr>
			<tr><td>Sewn-Eye Drake</td><td>2{U/R}B</td></tr>
			<tr><td>Thought-Knot Seer</td><td>3C</td></tr>
			<tr><td>Gurmag Angler</td><td>1B</td></tr>
			<tr><td>Fireball</td><td>4R</td></tr>
			<tr><td>Beseech the Queen</td><td>2BB</td></tr>
		</table>
		<p>Now that you've entered all of this information, you probably don't want to do it again. Move your mouse and click the "Copy" button three times to make a playset of the card.</p>

		<button class="dark_look_clickable" style="width:100%" onclick="toggleAddingCardsHelp()">Ok</button>
	</div>
	
	<div id="ui help" class="help_popup">
		<header>User Interface</header>
		<header style="font-size:16px">Tabletop</header>
		<dl style="padding: 0px 15px 0px 15px">
			<dt>Single click on card</dt><dd>Tap / untap card</dd>
			<dt>Double click on card sleeve</dt><dd>Flip card to front</dd>
			<dt>Double click on non-transformable card</dt><dd>Flip card to sleeve</dd>
			<dt>Double click on transformable card</dt><dd>Transform card</dd>
			<dt>Click and drag on card</dt><dd>Move card</dd>
			<dt>Hover over card</dt><dd>Magnify card</dd>
			<dt>Click and drag on counter</dt><dd>Move counter</dd>
			<dt>Single click on background</dt><dd>Deselect</dd>
			<dt>Click and drag left on background</dt><dd>Select all cards and counters that overlap the selection box</dd>
			<dt>Click and drag right on background</dt><dd>Select all cards and counters that are wholly within the selection box</dd>
			<dt>Single click on untapped card in selection</dt><dd>Tap all cards in selection</dd>
			<dt>Single click on tapped card in selection</dt><dd>Untap all cards in selection</dd>
			<dt>Double click on card sleeve in selection</dt><dd>Flip all cards in selection to front</dd>
			<dt>Double click on non-transformable card in selection</dt><dd>Flip all cards in selection to sleeve</dd>
			<dt>Double click on transformable card in selection</dt><dd>Transform all transformable cards in selection</dd>
			<dt>Click and drag on card or counter in selection</dt><dd>Move selection</dd>
		</dl>
		<header style="font-size:16px">Toolbar</header>
		<dl style="padding: 0px 15px 0px 15px">
			<dt>Enter card image URL here</dt><dd>Paste the url to a card image here</dd>
			<dt>Add Card</dt><dd>Creates a new card with the entered card image</dd>
			<dt>Add Counter</dt><dd>Creates a new counter</dd>
			<dt>File&rarr;Save</dt><dd>Downloads the current state of this page</dd>
			<dt>File&rarr;Name</dt><dd>The title of this page, and the filename when you save it</dd>
			<dt>File&rarr;Card Sleeve Image</dt><dd>The image URL to use for the sleeve image</dd>
			<dt>Game&rarr;New Game</dt><dd>Arranges the tabletop elements for a new game</dd>
			<dt>Game&rarr;Mulligan</dt><dd>Arranges the tabletop elements for a new game, but with one fewer drawn card</dd>
			<dt>Game&rarr;Starting Life</dt><dd>The initial value for the life counters in a new game</dd>
			<dt>Sort By&rarr;Cost</dt><dd>Sorts the card by the total amount of mana required to cast them</dd>
			<dt>Sort By&rarr;Color</dt><dd>Sorts the cards by the colors of mana required to cast them, and the colors they can produce</dd>
			<dt>Sort By&rarr;Type</dt><dd>Sorts the cards by card type</dd>
			<dt>Sort By&rarr;Purpose</dt><dd>Sorts the cards by the user-inputted purpose</dd>
			<dt>Sort By&rarr;Curvability</dt><dd>Sorts the cards by the probability you can cast them on-curve, on the play, without mulliganing</dd>
			<dt>Sideboard</dt><dd>Shows / hides the sideboard</dd>
			<dt>Sideboard&rarr;Show / Hide Sideboard</dt><dd>Shows / hides the sideboard</dd>
			<dt>Sideboard&rarr;Dump Sideboard</dt><dd>Dumps the cards in the sideboard onto the tabletop</dd>
			<dt>Selection&rarr;Stack</dt><dd>Stacks the cards in the selection. Face-up cards are stacked in a column so you can see their names, Face-down cards are stacked in a pile.</dd>
			<dt>Selection&rarr;Shuffle</dt><dd>Stacks the cards in the selection into a face-down shuffled pile</dd>
			<dt>Selection&rarr;Delete&rarr;Confirm</dt><dd>Deletes all cards and counters in the selection</dd>
			<dt>Selection&rarr;Select All</dt><dd>Selects all cards and counters on the tabletop</dd>
			<dt>Help&rarr;Adding Cards</dt><dd>Shows / hides the instructions for adding cards</dd>
			<dt>Help&rarr;User Interface</dt><dd>Shows / hides this</dd>
			<dt>Help&rarr;Analysis</dt><dd>Shows / hides the description of the manacost analysis</dd>
		</dl>
		<button class="dark_look_clickable" style="width:100%" onclick="toggleUserInterfaceHelp()">Ok</button>
	</div>

	<div id="analysis help" class="help_popup">
		<header>Analysis</header>
		<p>Coming Soon</p>
		<button class="dark_look_clickable" style="width:100%" onclick="toggleAnalysisHelp()">Ok</button>
	</div>

	<script>
var clickedElement;
var cardWidth = 212; //156
var cardHeight = 296; //222
var nameHeight = 29; //22
var toolbarHeight = 41;

/*
  _    _ _   _ _ _   _           
 | |  | | | | (_) | (_)          
 | |  | | |_| |_| |_ _  ___  ___ 
 | |  | | __| | | __| |/ _ \/ __|
 | |__| | |_| | | |_| |  __/\__ \
  \____/ \__|_|_|\__|_|\___||___/
                                 
*/                 

function getDocumentWidth() {
	return Math.max(
		document.body.scrollWidth,
		document.documentElement.scrollWidth,
		document.body.offsetWidth,
		document.documentElement.offsetWidth,
		document.documentElement.clientWidth
	);
}

function getDocumentHeight() {
	return Math.max(
		document.body.scrollHeight,
		document.documentElement.scrollHeight,
		document.body.offsetHeight,
		document.documentElement.offsetHeight,
		document.documentElement.clientHeight
	);
}

function resizeDocument()
{
	//Set document size to extent of interior elements
	document.body.style.width = '100%';
	document.body.style.height = '100%';
	document.body.style.width = getDocumentWidth() + 'px';
	document.body.style.height = getDocumentHeight() + 'px';
}

function getScrollX()
{
	if(window.pageXOffset!= undefined){
		return pageXOffset;
	}
	else{
		var d= document, r= d.documentElement, b= d.body;
		return r.scrollLeft || b.scrollLeft || 0;
	}
}

function getScrollY()
{
	if(window.pageYOffset!= undefined){
		return pageYOffset;
	}
	else{
		var d= document, r= d.documentElement, b= d.body;
		return r.scrollTop || b.scrollTop || 0;
	}
}

function getXCoordOfMouse()
{
	return window.event.x + getScrollX() - 2;
}
function getYCoordOfMouse()
{
	return window.event.y + getScrollY() - 2;
}

function isMouseOverElement(element)
{
	var mouseX = getXCoordOfMouse();
	var mouseY = getYCoordOfMouse();
	var boundingRectangle = element.getBoundingClientRect();

	if (mouseX > boundingRectangle.left &&
		mouseX < (boundingRectangle.left + boundingRectangle.width) &&
		mouseY > boundingRectangle.top &&
		mouseY < (boundingRectangle.top + boundingRectangle.height))
	{
		return true;
	} else {
		return false;
	}
}

//Checks if an element has a particular class
function hasClass(element, cls) {
    return (' ' + element.className + ' ').indexOf(' ' + cls + ' ') > -1;
}

function hideElement(element){
	element.style.display = "none";
}

function showElement(element, displayType){
	element.style.display = displayType||"block";
}

function toggleVisibility(element, displayType){
	var style = window.getComputedStyle(element);
	if(style.display == "none"){
		element.style.display = displayType||"block";
	} else {
		element.style.display = "none";
	}
}

function padToFour(number) {
  if (number<=9999) { number = ("000"+number).slice(-4); }
  return number;
}

function saveDocument(){
  // Construct the <a> element
  var link = document.createElement("a");
  link.download = (document.getElementById("deck name").value || "MTG Deck") + ".html";
  // Construct the uri
  var uri = 'data:text/csv;charset=utf-8;base64,' + window.btoa(document.documentElement.outerHTML);
  link.href = uri;
  document.body.appendChild(link);
  link.click();
  // Cleanup the DOM
  document.body.removeChild(link);
}

/*
  _    _ _____    _____            _             _ _           
 | |  | |_   _|  / ____|          | |           | | |          
 | |  | | | |   | |     ___  _ __ | |_ _ __ ___ | | | ___ _ __ 
 | |  | | | |   | |    / _ \| '_ \| __| '__/ _ \| | |/ _ \ '__|
 | |__| |_| |_  | |___| (_) | | | | |_| | | (_) | | |  __/ |   
  \____/|_____|  \_____\___/|_| |_|\__|_|  \___/|_|_|\___|_|   
                                                                                                                   
*/

function toggleAddingCardsHelp() {
	toggleVisibility(document.getElementById("adding cards help"));
	document.getElementById("ui help").style.display = "none";
	document.getElementById("analysis help").style.display = "none";
}

function toggleUserInterfaceHelp() {
	document.getElementById("adding cards help").style.display = "none";
	toggleVisibility(document.getElementById("ui help"));
	document.getElementById("analysis help").style.display = "none";
}

function toggleAnalysisHelp() {
	document.getElementById("adding cards help").style.display = "none";
	document.getElementById("ui help").style.display = "none";
	toggleVisibility(document.getElementById("analysis help"));
}

function updateDocumentTitleWithDeckName(){
	var deckName = document.getElementById("deck name").value || "MTG Deck";
	document.title = deckName;
}

function incrementCounter(e){
	var sender = (e && e.target) || (window.event && window.event.srcElement);
	var counter = sender.parentNode;
	var input = counter.childNodes[0];
	input.innerHTML = parseInt(input.innerHTML)+1;
}

function decrementCounter(e){
	var sender = (e && e.target) || (window.event && window.event.srcElement);
	var counter = sender.parentNode;
	var input = counter.childNodes[0];
	input.innerHTML = parseInt(input.innerHTML)-1;
}

function dragCounter(e){
	var sender = (e && e.target) || (window.event && window.event.srcElement);
	var counter = sender.parentNode;
	clickedElement = counter;
	startDrag(e);
}

function addCounter(initialValue, xOffset, yOffset){
	var playmat = document.getElementById("playmat");
	var counterCont = document.getElementById("counter_container");
	var counterNumber = parseInt(counterCont.getAttribute("numcounters"));
	var counter = document.getElementById("counter_template").cloneNode(true);
	counter.id = "counter"+counterNumber;
	counter.style.left = (xOffset || (100 + 100*counterNumber)) + "px";
	counter.style.top = (yOffset || (100 + toolbarHeight))+ "px";
	counter.style.backgroundColor = "rgb("+parseInt(Math.random()*155+100)+","+parseInt(Math.random()*155+100)+","+parseInt(Math.random()*155+100)+")";
	playmat.appendChild(counter);
	counterCont.setAttribute("numcounters", counterNumber+1);
	var input = counter.childNodes[0];
	if (arguments.length == 0)
	{
		input.innerHTML = 1;
	} else {
		input.innerHTML = initialValue;
	}
}

function deleteAllCounters()
{
	var playmat = document.getElementById('playmat');
	var elementsOnMat = playmat.getElementsByTagName('*');
	var countersOnMat = []
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		if ( hasClass(elementsOnMat[i],'counter') && elementsOnMat[i].parentNode == playmat)
		{
			countersOnMat.push(elementsOnMat[i]);
		}
	}
	for (i = 0; i < countersOnMat.length; ++i)
	{
		countersOnMat[i].parentNode.removeChild(countersOnMat[i]);
	}
	document.getElementById("counter_container").setAttribute("numcounters","0");
}

var enableDelayedHover = 0;
var hoverEventId = 0;
function startHoverOverCard()
{
	enableDelayedHover = 1;
	hoverEventId++;
	if (hoverEventId >= 100) {
		hoverEventId = 0;
	}
	setTimeout(delayedHoverOverCard, 1000, hoverEventId);
}

var hoveredElement;
function mouseEnterCard(e){
	// determine event object
	if (!e) {
		var e = window.event;
	}
	// IE uses srcElement, others use target
	hoveredElement = e.target ? e.target : e.srcElement;
	if (hasClass(hoveredElement, 'card')){
		startHoverOverCard();
	}
}

function mouseLeaveCard(e){
	// determine event object
	if (!e) {
		var e = window.event;
	}
	// IE uses srcElement, others use target
	var targetElement = e.target ? e.target : e.srcElement;
	enableDelayedHover = 0;
}

var mouseOverSideboard = false;
function mouseEnterSideboard(e){
	mouseOverSideboard = true;
}

function mouseLeaveSideboard(e){
	mouseOverSideboard = false;
}

//
function delayedHoverOverCard(triggeringHoverEventId){
	if (!drag && enableDelayedHover && triggeringHoverEventId == hoverEventId) {
		enableDelayedHover = 0;
		showCardInfoMenu(hoveredElement);
	}
}

//Handles mouseDown events

var timeOfPreviousCardClick;
var timeOfPreviousPreviousCardClick;
var clickCounter = 0;
function mouseDownCard(e){
	// determine event object
	if (!e) {
		var e = window.event;
	}
	// IE uses srcElement, others use target
	var tempClickedElement = e.target ? e.target : e.srcElement;
	//Prevent default behavior
	if(tempClickedElement.preventDefault) tempClickedElement.preventDefault();
	//If this is a different element, reset the click counter
	if ( tempClickedElement != clickedElement )
	{
		clickCounter = 0;
	}
	clickedElement = tempClickedElement;
	//Increment the click counter on this element
	++clickCounter;

	if (hasClass(clickedElement, 'card')){
		//console.log('click:' + clickCounter);
		//Set a delayed function to check for double and triple clicks
		setTimeout(evaluateNumClicks, 200, clickCounter);
		if (hasClass(clickedElement, 'sideboarded'))
		{
			//Move this to the playmat
			var playmat = document.getElementById('playmat');
			var sideboard = document.getElementById('sideboard');
			//Remove sideboarded class
			clickedElement.className = clickedElement.className.replace( /(?:^|\s)sideboarded(?!\S)/g , '' );
			//Put it on the playmat
			var rect = sideboard.getBoundingClientRect();
			var documentScrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
			var documentScrollLeft = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
			clickedElement.style.top = parseInt(clickedElement.style.top) + parseInt(rect.top) - sideboard.scrollTop + documentScrollTop + 'px';
			clickedElement.style.left= parseInt(clickedElement.style.left) + parseInt(rect.left) + documentScrollLeft + 'px';
			playmat.appendChild(clickedElement);
		}
	}
	if (hasClass(clickedElement, 'draggable')){
		startDrag(e);
	}
	enableDelayedHover = 0;
}

var numClicks = 0;
function evaluateNumClicks(triggeringClickCounter){
	//console.log('resolving click:' + triggeringClickCounter);
	//Are they trying to drag it?
	if (moved)
	{
		//Reset click counter
		numClicks = 0;
	}
	//Have they stopped clicking?
	else if (clickCounter == triggeringClickCounter)
	{
		//Count this click
		++numClicks
		//Resolve the proper action
		if (numClicks == 1)
		{
			//Single click = Tap/Untap
			tapOrUntapCard(clickedElement);
		}
		else if (numClicks == 2)
		{
			//Double click = Flip
			flipCard(clickedElement);
		}
		//Reset click counter
		numClicks = 0;
	} else {
		//They haven't stopped clicking. Increment the click counter without resolving
		numClicks++;
	}
}

function mouseUpCard(e){
	// determine event object
	if (!e) {
		var e = window.event;
	}
	// IE uses srcElement, others use target
	hoveredElement = e.target ? e.target : e.srcElement;
	if (hasClass(hoveredElement, 'card')){
		startHoverOverCard();
	}
}

//Prepares to drag the element
var startCoordX;
var startCoordY;
var endCoordX;
var endCoordY;
var select = false;
function startSelection(e) {
	// determine event object
	if (!e) {
		var e = window.event;
	}

	var playmat = document.getElementById("playmat");

	//Prevent default behavior
	if(playmat.preventDefault)
	{
		playmat.preventDefault();
	}

	//Check that they weren't clicking on something else
	var targetElement = e.target ? e.target : e.srcElement;
	if(playmat == targetElement)
	{
		deselectAll();

		// calculate event X, Y coordinates
		startCoordX = getXCoordOfMouse();
		startCoordY = getYCoordOfMouse();

		var selector = document.getElementById("selector");
		selector.style.top = startCoordY + 'px';
		selector.style.left = startCoordX + 'px';
		selector.style.width = '0px';
		selector.style.height = '0px';
		selector.className = 'blue_selector';
		
		// enable moving selector element when the mouse moves
		select = true;
	}
    return false;
}

//Prepares to drag the element
var coordX;
var coordY;
var drag = false;
var moved = false;
var elementToDrag;
function startDrag(e) {

	//Did they click on a selected element?
	if (hasClass(clickedElement, 'selected'))
	{
		//Drag the whole selection
		elementToDrag = document.getElementById('selector');
	} else {
		//Drag just the element that was clicked
		elementToDrag = clickedElement;
		//Bring the element to the front
		elementToDrag.parentNode.appendChild(elementToDrag);
	}

	// calculate event X, Y coordinates
	offsetX = window.event.x;
	offsetY = window.event.y;

	// assign default values for top and left properties
	if(!elementToDrag.style.left) { elementToDrag.style.left='0px'};
	if (!elementToDrag.style.top) { elementToDrag.style.top='0px'};

	// calculate integer values for top and left 
	// properties
	coordX = parseInt(elementToDrag.style.left);
	coordY = parseInt(elementToDrag.style.top);
	

	// enable moving div element
	drag = true;
	moved = false;
    return false;
}

//Called whenever the mouse moves on the document, so make this fast
function dragElement(e) {
	//If the user is currently dragging an element
	if (drag)
	{
		if (!e) { var e= window.event};
		// var targ=e.target?e.target:e.srcElement;
		// move div element
		if (hasClass(elementToDrag,'sideboarded'))
		{
			elementToDrag.style.left=coordX+e.clientX-offsetX+'px';
			elementToDrag.style.top=coordY+e.clientY-offsetY+'px';
		} else {
			if (coordX+e.clientX-offsetX < 0){
				elementToDrag.style.left='0px';
			} else {
				elementToDrag.style.left=coordX+e.clientX-offsetX+'px';
			}
			if (coordY+e.clientY-offsetY < toolbarHeight){		//Don't move elements over the toolbar
				elementToDrag.style.top= toolbarHeight + 'px';
			} else {
				elementToDrag.style.top=coordY+e.clientY-offsetY+'px';
			}
		}
		
		if ((e.clientX-offsetX) != 0 || (e.clientY-offsetY) != 0)
		{
			moved = true;
		}
		hideSelector();
		select = false;
	//Else, if the user is currently trying to select things
	} else if (select) {
		var selector = document.getElementById("selector");
		//Get the current mouse position
		endCoordX = getXCoordOfMouse();
		endCoordY = getYCoordOfMouse();
		//Update the selection box's Y position and height to span the start and end coords
		if (startCoordY < endCoordY)
		{
			selector.style.top = startCoordY + 'px';
			selector.style.height = (endCoordY - startCoordY) + 'px'
		} else {
			//Can't select the toolbar
			if (endCoordY < toolbarHeight)
			{
				endCoordY = toolbarHeight;
			}
			selector.style.top = endCoordY + 'px';
			selector.style.height = (startCoordY - endCoordY) + 'px'
		}
		//Update the selection box's X position and width to span the start and end coords
		if (startCoordX < endCoordX)
		{
			selector.style.left = startCoordX + 'px';
			selector.style.width = (endCoordX - startCoordX) + 'px'
			//If the user is selecting to the right, use blue selection box
			selector.className = "blue_selector";
		} else {
			selector.style.left = endCoordX + 'px';
			selector.style.width = (startCoordX - endCoordX) + 'px'
			//If the user is selecting to the left, use green selection box
			selector.className = "green_selector";
		}
	}
	return false;
}

//Make the selection box transparent
function hideSelector() {
	var selector = document.getElementById('selector');
	selector.className = 'invisible_selector';
	selector.style.width = '0px';
	selector.style.height = '0px';
}

function selectAll() {
	var playmat = document.getElementById('playmat');
	var elementsOnMat = playmat.getElementsByTagName('*');
	var selectedElements = [];
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		//Check that this is a top-level element
		if (elementsOnMat[i].parentNode == playmat && hasClass(elementsOnMat[i], 'draggable'))
		{
			selectedElements.push(elementsOnMat[i]);
		}
	}
	groupSelectedElements(selectedElements);
}

//Move all listed elements into the "selected" div, and add the 'selected' class
function groupSelectedElements(selectedElements) {
	if (selectedElements.length > 0)
	{
		var i;
		var selector = document.getElementById('selector');
		//Tighten the top and left of the selector to the selected elements
		//That way when the selection gets dragged it gets stopped at a reasonable
		//position when the top or left of the page is hit.
		var minTop = parseInt(selectedElements[0].style.top);
		var minLeft = parseInt(selectedElements[0].style.left);
		for (i = 1; i < selectedElements.length; ++i)
		{
			if (parseInt(selectedElements[i].style.top) < minTop )
			{
				minTop = parseInt(selectedElements[i].style.top);
			}
			if (parseInt(selectedElements[i].style.left) < minLeft )
			{
				minLeft = parseInt(selectedElements[i].style.left);
			}
		}
		selector.style.top = minTop + 'px';
		selector.style.left = minLeft + 'px';
		//Now move the elements into the selector div
		for (i = 0; i < selectedElements.length; ++i)
		{
			//Also add a class so they look like they are selected
			selectedElements[i].className += ' selected';
			selectedElements[i].style.top = parseInt(selectedElements[i].style.top) - parseInt(selector.style.top) + 'px';
			selectedElements[i].style.left= parseInt(selectedElements[i].style.left) - parseInt(selector.style.left) + 'px';
			selector.appendChild(selectedElements[i]);
		}
		/*document.getElementById("shuffle button").style.display = 'block';
		document.getElementById("stack button").style.display = 'block';
		document.getElementById("delete selection button").style.display = 'block';*/
	}
}

//Remove all selected elements from the "selected" div, unset their style, and empty the array of selected elements
function deselectAll()
{
	var i = 0;
	var playmat = document.getElementById('playmat');
	var selector = document.getElementById('selector');
	var selectedElements = [];
	var elementsInSelector = selector.getElementsByTagName('*');
	for (i = 0; i < elementsInSelector.length; ++i)
	{
		//Check that this is a top-level element
		if (elementsInSelector[i].parentNode == selector)
		{
			selectedElements.push(elementsInSelector[i]);
		}
	}
	for (i = 0; i < selectedElements.length; ++i)
	{
		selectedElements[i].style.top = parseInt(selectedElements[i].style.top) + parseInt(selector.style.top) + 'px';
		selectedElements[i].style.left= parseInt(selectedElements[i].style.left) + parseInt(selector.style.left) + 'px';
		playmat.appendChild(selectedElements[i]);
	}
	for (i = 0; i < selectedElements.length; ++i)
	{
		selectedElements[i].className = selectedElements[i].className.replace( /(?:^|\s)selected(?!\S)/g , '' )
	}
	/*document.getElementById("shuffle button").style.display = 'none';
	document.getElementById("stack button").style.display = 'none';
	document.getElementById("delete selection button").style.display = 'none';*/
}

//Called whenever the mouse button goes up on the document
function stopDrag() {
	if (drag)
	{
		drag=false;
		var playmat = document.getElementById("playmat");
		var sideboard = document.getElementById("sideboard");

		//the sideboard is visible and it was dropped in the sideboard
		if (mouseOverSideboard && sideboard.style.visibility == 'visible')
		{
			//If the dragged element is a card and the sideboard is visible and it was dropped in the sideboard
			if (hasClass(elementToDrag, 'card'))
			{
				if (!hasClass(elementToDrag, 'sideboarded'))
				{
					elementToDrag.className += ' sideboarded';
				}
				sideboard.appendChild(elementToDrag);
				sortSideboard();
			} else if (elementToDrag.id == 'selector' ) {
				//If the selection is being dragged
				var selectedElements = [];
				var elementsInSelector = elementToDrag.getElementsByTagName('*');
				for (i = 0; i < elementsInSelector.length; ++i)
				{
					//Check that this is a top-level element
					if (elementsInSelector[i].parentNode == elementToDrag)
					{
						selectedElements.push(elementsInSelector[i]);
					}
				}
				for (i = 0; i < selectedElements.length; ++i)
				{
					//Only put cards in the sideboard
					if (hasClass(selectedElements[i], 'card'))
					{
						selectedElements[i].className = selectedElements[i].className.replace( /(?:^|\s)selected(?!\S)/g , '' )
						if (!hasClass(selectedElements[i], 'sideboarded'))
						{
							selectedElements[i].className += ' sideboarded';
						}
						sideboard.appendChild(selectedElements[i]);
					}
				}
				sortSideboard();
				deselectAll();
			}
		}


		//Resize document to fit
		resizeDocument();
	}
	
	if (select)
	{
		var selector = document.getElementById("selector");
		//Go through all cards and check if they are being selected
		var playmat = document.getElementById("playmat");
		var elementsOnMat = playmat.getElementsByTagName('*');

		var i, element;
		var topBoundary = parseInt(selector.style.top);
		var leftBoundary = parseInt(selector.style.left);
		var bottomBoundary = topBoundary + parseInt(selector.style.height);
		var rightBoundary = leftBoundary + parseInt(selector.style.width);
		var elementTop = 0;
		var elementLeft = 0;
		var elementBottom = 0;
		var elementRight = 0;
		var elementStyle;
		var i = 0;

		var selectedElements = new Array();
		if (selector.className == "blue_selector")
		{
			hideSelector();
			//Blue selector only selects elements that are entirely within the selection box	
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				//Check that this is a draggable top-level element
				if (elementsOnMat[i].parentNode == playmat && hasClass(elementsOnMat[i],'draggable'))
				{
					elementStyle = window.getComputedStyle(elementsOnMat[i]);
					elementTop = parseInt(elementsOnMat[i].style.top);
					elementLeft = parseInt(elementsOnMat[i].style.left);
					elementRight = elementLeft + parseInt(elementStyle.width);
					elementBottom = elementTop + parseInt(elementStyle.height);

					//Check its coordinates
					if (elementTop >= topBoundary &&
						elementLeft >= leftBoundary &&
						elementBottom <= bottomBoundary &&
						elementRight <= rightBoundary)
					{
						selectedElements.push(elementsOnMat[i]);
					}
				}
			}
		} else if (selector.className == "green_selector"){
			hideSelector();
			//Green selector slects any elements that overlap the selection box
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				//Check that this is a draggable top-level element
				if (elementsOnMat[i].parentNode == playmat && hasClass(elementsOnMat[i],'draggable'))
				{
					elementStyle = window.getComputedStyle(elementsOnMat[i]);
					elementTop = parseInt(elementsOnMat[i].style.top);
					elementLeft = parseInt(elementsOnMat[i].style.left);
					elementRight = elementLeft + parseInt(elementStyle.width);
					elementBottom = elementTop + parseInt(elementStyle.height);
					//Check its coordinates
					if (elementLeft <= rightBoundary &&
						elementRight >= leftBoundary &&
						elementTop <= bottomBoundary &&
						elementBottom >= topBoundary )
					{
						selectedElements.push(elementsOnMat[i]);
					}
				}
			}
		}
		//Move the selected elements to the "selected" div for O(1) movement
		groupSelectedElements(selectedElements);
		
		select = false
	}
}

var selectedCard;
function showCardInfoMenu(element) {
	if (hasClass(element, 'card')){
		selectedCard = element;
		if (hasClass(element, 'selected'))
		{
			var selector = document.getElementById('selector');
			document.getElementById('card info popup').style.top = parseInt(selectedCard.style.top) - 5 + parseInt(selector.style.top)  + 'px';
			document.getElementById('card info popup').style.left = parseInt(selectedCard.style.left) - 5 + parseInt(selector.style.left) + 'px';
		} else if (hasClass(element, 'sideboarded')) {
			var sideboard = document.getElementById('sideboard'); //TODO
			var documentScrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
			document.getElementById('card info popup').style.top = parseInt(selectedCard.style.top) - 5 - sideboard.scrollTop + documentScrollTop + 'px';
			document.getElementById('card info popup').style.right = 180 + 'px';
			document.getElementById('card info popup').style.left = "";
		} else {
			document.getElementById('card info popup').style.top = parseInt(selectedCard.style.top) - 5 + 'px';
			document.getElementById('card info popup').style.left = parseInt(selectedCard.style.left) - 5 + 'px';
		}
		hideEditCard();
		document.getElementById('magnified card view').src = selectedCard.src;
		showElement(document.getElementById('card info popup'));
	}
}

function hideCardInfoMenu() {
	hideEditCard();
	numCopies = 0;
	hideElement(document.getElementById('card info popup'));
}

function loadEditCardSettings()
{
	//Load the settings
	document.getElementById('card name input').value = selectedCard.getAttribute('name');
	document.getElementById('purpose input').value = selectedCard.getAttribute('purpose');
	if (selectedCard.getAttribute('token') == 'true'){
		document.getElementById('card type').value = "token";

	} else if (selectedCard.getAttribute('land') == 'true') {
		document.getElementById('card type').value = "land";

	} else if (selectedCard.getAttribute('creature') == 'true') {
		document.getElementById('card type').value = "creature";

	} else if (selectedCard.getAttribute('planeswalker') == 'true') {
		document.getElementById('card type').value = "planeswalker";

	} else if (selectedCard.getAttribute('artifact') == 'true') {
		document.getElementById('card type').value = "artifact";

	} else if (selectedCard.getAttribute('enchantment') == 'true') {
		document.getElementById('card type').value = "enchantment";

	} else if (selectedCard.getAttribute('sorcery') == 'true') {
		document.getElementById('card type').value = "sorcery";

	} else if (selectedCard.getAttribute('instant') == 'true') {
		document.getElementById('card type').value = "instant";

	} else {
		document.getElementById('card type').value = "land";
	}
	/*document.getElementById('land checkbox').checked = selectedCard.getAttribute('land') == 'true';
	document.getElementById('creature checkbox').checked = selectedCard.getAttribute('creature') == 'true';
	document.getElementById('planeswalker checkbox').checked = selectedCard.getAttribute('planeswalker') == 'true';
	document.getElementById('artifact checkbox').checked = selectedCard.getAttribute('artifact') == 'true';
	document.getElementById('enchantment checkbox').checked = selectedCard.getAttribute('enchantment') == 'true';
	document.getElementById('sorcery checkbox').checked = selectedCard.getAttribute('sorcery') == 'true';
	document.getElementById('instant checkbox').checked = selectedCard.getAttribute('instant') == 'true';
	document.getElementById('token checkbox').checked = selectedCard.getAttribute('token') == 'true';*/
	document.getElementById('casting cost input').value = selectedCard.getAttribute('casting_cost');
	
	if (selectedCard.getAttribute('commander') == 'true')
	{
		document.getElementById('commander selection').value = "commander";
	} else {
		document.getElementById('commander selection').value = "";
	}
	//document.getElementById('commander checkbox').checked = selectedCard.getAttribute('commander') == 'true';
	var manaProductionBitVector = parseInt(selectedCard.getAttribute('mana_production_bitvector'));
	document.getElementById('produces white checkbox').checked = manaProductionBitVector & 0x01;
	document.getElementById('produces blue checkbox').checked = manaProductionBitVector & 0x02;
	document.getElementById('produces black checkbox').checked = manaProductionBitVector & 0x04;
	document.getElementById('produces red checkbox').checked = manaProductionBitVector & 0x08;
	document.getElementById('produces green checkbox').checked = manaProductionBitVector & 0x10;
	document.getElementById('produces colorless checkbox').checked = manaProductionBitVector & 0x20;
	document.getElementById('card back input').value = selectedCard.getAttribute('back');
}

function saveEditCardSettings()
{
	selectedCard.setAttribute('name', document.getElementById('card name input').value );
	selectedCard.setAttribute('purpose', document.getElementById('purpose input').value );

	selectedCard.setAttribute('land', 'false' );
	selectedCard.setAttribute('creature', 'false' );
	selectedCard.setAttribute('planeswalker', 'false' );
	selectedCard.setAttribute('artifact', 'false' );
	selectedCard.setAttribute('enchantment', 'false' );
	selectedCard.setAttribute('sorcery', 'false' );
	selectedCard.setAttribute('instant', 'false' );
	selectedCard.setAttribute('token', 'false' );

	var selectedCardType = document.getElementById('card type').value;

	if (selectedCardType == 'land'){
		selectedCard.setAttribute('land', 'true' );

	} else if (selectedCardType == 'creature'){
		selectedCard.setAttribute('creature', 'true' );

	} else if (selectedCardType == 'planeswalker'){
		selectedCard.setAttribute('planeswalker', 'true' );

	} else if (selectedCardType == 'artifact'){
		selectedCard.setAttribute('artifact', 'true' );
		
	} else if (selectedCardType == 'enchantment'){
		selectedCard.setAttribute('enchantment', 'true' );
		
	} else if (selectedCardType == 'sorcery'){
		selectedCard.setAttribute('sorcery', 'true' );
		
	} else if (selectedCardType == 'instant'){
		selectedCard.setAttribute('instant', 'true' );
		
	} else if (selectedCardType == 'token'){
		selectedCard.setAttribute('token', 'true' );
		
	}

	/*selectedCard.setAttribute('land', document.getElementById('land checkbox').checked );
	selectedCard.setAttribute('creature', document.getElementById('creature checkbox').checked );
	selectedCard.setAttribute('planeswalker', document.getElementById('planeswalker checkbox').checked );
	selectedCard.setAttribute('artifact', document.getElementById('artifact checkbox').checked );
	selectedCard.setAttribute('enchantment', document.getElementById('enchantment checkbox').checked );
	selectedCard.setAttribute('sorcery', document.getElementById('sorcery checkbox').checked );
	selectedCard.setAttribute('instant', document.getElementById('instant checkbox').checked );
	selectedCard.setAttribute('token', document.getElementById('token checkbox').checked );*/

	selectedCard.setAttribute('casting_cost', document.getElementById('casting cost input').value);

	if (document.getElementById('commander selection').value == 'commander')
	{
		selectedCard.setAttribute('commander', 'true' );
	} else {
		selectedCard.setAttribute('commander', 'false' );
	}

	//selectedCard.setAttribute('commander', document.getElementById('commander checkbox').checked );

	var manaProductionBitVector = 0;
	if (document.getElementById('produces white checkbox').checked) { manaProductionBitVector |= 0x01;}
	if (document.getElementById('produces blue checkbox').checked) { manaProductionBitVector |= 0x02;}
	if (document.getElementById('produces black checkbox').checked) { manaProductionBitVector |= 0x04;}
	if (document.getElementById('produces red checkbox').checked) { manaProductionBitVector |= 0x08;}
	if (document.getElementById('produces green checkbox').checked) { manaProductionBitVector |= 0x10;}
	if (document.getElementById('produces colorless checkbox').checked) { manaProductionBitVector |= 0x20;}
	selectedCard.setAttribute('mana_production_bitvector', manaProductionBitVector );
	selectedCard.setAttribute('back', document.getElementById('card back input').value );
}

function hideEditCard()
{
	//Check if the user made changes
	if (document.getElementById("edit card control panel").style.display == 'block')
	{
		//Hide the edit card control panel and save the settings
		saveEditCardSettings();
		hideElement(document.getElementById("edit card control panel"));
	}
	hideElement(document.getElementById('analyze card results'));
}

function viewEditCard()
{
	//Load the settings and make the edit card control panel visible
	loadEditCardSettings();
	updateEditCardFormByType();
	showElement(document.getElementById("edit card control panel"));
}

function toggleEditCard()
{
	//If the edit card panel was visible, hide it and save settings
	if (document.getElementById("edit card control panel").style.display == 'block')
	{
		hideEditCard();
	}
	else
	{
		viewEditCard();
	}
}

function updateEditCardFormByType()
{
	var landMenuElement = document.getElementById('land menu');
	var nonlandMenuElement = document.getElementById('nonland menu');
	var permanentMenuElement = document.getElementById('permanent menu');
	var selectedCardType = document.getElementById('card type').value;
	//Is this a land?
	if (selectedCardType == 'land')
	{
		//Show land stuff
		showElement(landMenuElement);
		//Is this a creature?
		if (selectedCardType == 'creature' || selectedCardType == 'planeswalker' || selectedCardType == 'artifact' || selectedCardType == 'enchantment')
		{
			showElement(permanentMenuElement);	//In case they print a legendary land creature, so that it can be your commander
		} else {
			hideElement(permanentMenuElement);
		}
		hideElement(nonlandMenuElement);
	}
	else
	{
		hideElement(landMenuElement);
		//Is this a creature, planeswalker, artifact, or enchantment
		if (selectedCardType == 'creature' || selectedCardType == 'planeswalker' || selectedCardType == 'artifact' || selectedCardType == 'enchantment')
		{
			showElement(nonlandMenuElement);
			showElement(permanentMenuElement);
		}
		else if (selectedCardType == 'sorcery' || selectedCardType == 'instant')
		{
			showElement(nonlandMenuElement);
			hideElement(permanentMenuElement);
		}
		else
		{
			hideElement(nonlandMenuElement);
			hideElement(permanentMenuElement);
		}
		//Hide land stuff
		hideElement(landMenuElement);
	}
}

var CardElement = function(imagesource) {
	this.element = document.createElement("img");
	this.element.src = imagesource;
	this.element.className = "draggable card";
	this.element.setAttribute("name", "");
	this.element.setAttribute("purpose", "");
	this.element.setAttribute("front", imagesource);
	this.element.setAttribute("back", "");
	this.element.setAttribute("land", false);
	this.element.setAttribute("creature", false);
	this.element.setAttribute("planeswalker", false);
	this.element.setAttribute("artifact", false);
	this.element.setAttribute("enchantment", false);
	this.element.setAttribute("sorcery", false);
	this.element.setAttribute("instant", false);
	this.element.setAttribute("token", false);
	this.element.setAttribute("casting_cost", "");
	this.element.setAttribute("commander", false);
	this.element.setAttribute('mana_production_bitvector', "0");
	this.element.style.top = '0px';
	this.element.style.left = '0px';
	this.element.addEventListener("mousedown", mouseDownCard);
	this.element.addEventListener("mouseup", mouseUpCard);
	this.element.addEventListener("mouseenter", mouseEnterCard);
	this.element.addEventListener("mouseleave", mouseLeaveCard);
	document.getElementById("playmat").appendChild(this.element);
	return this.element;
}

var Label = function(text) {
	this.element = document.createElement("div");
	this.element.className = "label";
	this.element.innerHTML = text;
	document.getElementById("playmat").appendChild(this.element);
	return this.element;
}

function deleteAllLabels() {
	//Get all the elements in the selection
	var elementsOnPlaymat = document.getElementById('playmat').getElementsByTagName('DIV');

	//Delete all the label elements
	var elementsToDelete = [];
	var i = 0;
	for (i = 0; i < elementsOnPlaymat.length; ++i)
	{
		if (hasClass(elementsOnPlaymat[i], 'label'))
		{
			elementsToDelete.push(elementsOnPlaymat[i]);
		}
	}

	for (i = 0; i < elementsToDelete.length; ++i)
	{
		elementsToDelete[i].parentNode.removeChild(elementsToDelete[i]);
	}
}

function addCard() {
	var cardImageUrlString = String(document.getElementById("cardimageurl").value);
	var urlRegex =/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
	var numCardsAdded = 0;
	var padding = 5;
	var playmat = document.getElementById("playmat");
	var sideboard = document.getElementById("sideboard");
	var numColumns = Math.floor((playmat.offsetWidth - sideboard.offsetWidth - 50 - padding - 25) / (cardWidth + padding));
	if (numColumns < 3)
	{
		numColumns = 3;
	}
	var newCard;
    cardImageUrlString.replace(urlRegex, function(url) {
    	newCard = CardElement(url);
    	newCard.style.top = Math.floor(numCardsAdded / numColumns) * (cardHeight + padding) + 25 + 'px';
    	newCard.style.left = (numCardsAdded % numColumns) * (cardWidth + padding) + 25 + 'px';
    	newCard.setAttribute("name", padToFour(numCardsAdded));
    	numCardsAdded = numCardsAdded + 1;
        return url;
    });
    if (numCardsAdded == 1)
    {
    	newCard.setAttribute("name", "");
    }
}

var numCopies = 0;
function copyCard() {
	//Save any changes
	saveEditCardSettings();
	var clone = selectedCard.cloneNode(true);
	clone.addEventListener("mousedown", mouseDownCard);
	clone.addEventListener("mouseup", mouseUpCard);
	clone.addEventListener("mouseenter", mouseEnterCard);
	clone.addEventListener("mouseleave", mouseLeaveCard);
	++numCopies;
	clone.style.top = parseInt(clone.style.top) + nameHeight*numCopies + "px";
	selectedCard.parentNode.appendChild(clone);
}

function deleteCard() {
	document.getElementById('magnified card view').src = "";
	hideCardInfoMenu();
	selectedCard.parentNode.removeChild(selectedCard);
}

function clearCardImageUrlEntry() {
	document.getElementById("cardimageurl").value = "";
}

function tapOrUntapCard(element) {
	//Is the card sideboarded?
	if (!hasClass(element, 'sideboarded'))
	{
		//Is the card already tapped?
		if (hasClass(element, 'rotated')){
			//Is the card part of a selection?
			if (hasClass(element, 'selected'))
			{
				//Untap all cards in the selection
				var elementsInSelector = document.getElementById('selector').getElementsByTagName('*');
				var i;
				for (i = 0; i < elementsInSelector.length; ++i)
				{
					if (hasClass(elementsInSelector[i],"card"))
					{
						elementsInSelector[i].className = elementsInSelector[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
					}
				}
			}
			else
			{
				//Untap just this card
				element.className = element.className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
			}
		} else {
			//Is the card part of a selection?
			if (hasClass(element, 'selected'))
			{
				//Tap all cards in the selection
				var elementsInSelector = document.getElementById('selector').getElementsByTagName('*');
				var i;
				for (i = 0; i < elementsInSelector.length; ++i)
				{
					if (hasClass(elementsInSelector[i],"card"))
					{
						if (!hasClass(elementsInSelector[i], 'rotated'))
						{
							elementsInSelector[i].className += ' rotated';
						}
					}
				}
			}
			else
			{
				//Tap just this card
				element.className += ' rotated';
			}
		}
	}
}

function flipCard(element)
{
	//Is this card part of a selection?
	if (hasClass(element, 'selected'))
	{
		var elementsInSelector = document.getElementById('selector').getElementsByTagName('*');
		var i;
		//Is the card face up?
		if (element.src == element.getAttribute("front"))
		{
			//Is this a double-faced card?
			if (element.getAttribute("back") != "")
			{
				//Transform all transformable cards
				for (i = 0; i < elementsInSelector.length; ++i)
				{
					if (hasClass(elementsInSelector[i],"card"))
					{
						//Is this a transformable card?
						if (elementsInSelector[i].getAttribute("back") != "")
						{
							elementsInSelector[i].src = elementsInSelector[i].getAttribute("back");
						}
					}
				}
			}
			else
			{
				//Conceal all cards
				for (i = 0; i < elementsInSelector.length; ++i)
				{
					if (hasClass(elementsInSelector[i],"card"))
					{
						elementsInSelector[i].src = document.getElementById("card sleeve image").value;
					}
				}
			}
		}
		else
		{
			//flip all cards to front side
			for (i = 0; i < elementsInSelector.length; ++i)
			{
				if (hasClass(elementsInSelector[i],"card"))
				{
					elementsInSelector[i].src = elementsInSelector[i].getAttribute("front");
				}
			}
		}
	}
	else
	{
		//Is the card face up?
		if (element.src == element.getAttribute("front"))
		{
			//Is this a double-faced card?
			if (element.getAttribute("back") != "")
			{
				//Double-faced card, transform
				element.src = element.getAttribute("back");
			} else {
				//Conceal this card
				element.src = document.getElementById("card sleeve image").value;
			}
		}
		else
		{
			//flip to front side
			element.src = element.getAttribute("front");
		}
	}
}

function shuffle()
{
	var xOffset = 0;
	var yOffset = 0;

	//Are any cards selected?
	var elementsToShuffle = document.getElementById('selector').getElementsByTagName('*');

	//Figure out which of the elements are cards
	var cardsToShuffle = [];
	var i = 0;
	for (i = 0; i < elementsToShuffle.length; ++i)
	{
		if (hasClass(elementsToShuffle[i], "card"))
		{
			cardsToShuffle.push(elementsToShuffle[i]);
		}
	}

	//Shuffle the cards
	var numCards = cardsToShuffle.length;
	
	for (i = 0; i < numCards; ++i)
	{
		//Select a card at random
		var index = Math.floor(Math.random() * cardsToShuffle.length);
		//Conceal the card
		cardsToShuffle[index].src = document.getElementById("card sleeve image").value;
		//Put it into the deck
		cardsToShuffle[index].style.top = yOffset + i + 'px';
		cardsToShuffle[index].style.left = xOffset + i + 'px';
		cardsToShuffle[index].className = cardsToShuffle[index].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToShuffle[index].parentNode.appendChild(cardsToShuffle[index]);
		//Remove it from the list of cards to be shuffled
		cardsToShuffle.splice(index,1);
	}

	//Resize document to fit
	resizeDocument();
}

var handSize = 7;
function newGame()
{
	handSize = 7;
	prepareGame(handSize);
}

function mulligan()
{
	if (handSize > 0)
	{
		handSize = handSize - 1;
	}
	prepareGame(handSize);
}

function prepareGame(handSize)
{
	//Get all the elements on the playmat
	var elementsOnPlaymat = document.getElementById('playmat').getElementsByTagName('*');
	var xOffset = 400;
	var yOffset = 700 + toolbarHeight;
	var deckXOffset = 10;
	var deckYOffset = 40 + toolbarHeight;
	var handXOffset = 10;
	var handYOffset = 300 + toolbarHeight;
	var commanderXOffset = 0;
	var commanderYOffset = deckYOffset;
	var tokensXOffset = 0;
	var tokensYOffset = deckYOffset;
	var lifeCounterXOffset = 300;
	var lifeCounterYOffset = 40 + toolbarHeight;
	var cardSeparation = 10;
	deleteAllCounters();
	deleteAllLabels();
	
	//Figure out which of the elements are non-commander cards
	var cardsToShuffle = [];
	var tokensToStack = [];
	var commandersToStack = [];
	var i = 0;
	for (i = 0; i < elementsOnPlaymat.length; ++i)
	{
		if (hasClass(elementsOnPlaymat[i], "card"))
		{
			if (elementsOnPlaymat[i].getAttribute('commander') == 'true' )
			{
				commandersToStack.push(elementsOnPlaymat[i]);
			} else if (elementsOnPlaymat[i].getAttribute('token') == 'true') {
				tokensToStack.push(elementsOnPlaymat[i]);
			} else {
				cardsToShuffle.push(elementsOnPlaymat[i]);
			}
		}
	}

	//Count how many cards we need to shuffle
	var numCards = cardsToShuffle.length;

	var numDrawnCards = Math.min(handSize, numCards);
	var numCardsLeftInDeck = numCards - numDrawnCards;

	var xEndOfDeck = deckXOffset + numCardsLeftInDeck + cardWidth;

	//Draw a hand of handSize cards
	for (i = 0; i < numDrawnCards; ++i)
	{
		//Select a card at random
		var index = Math.floor(Math.random() * cardsToShuffle.length);
		//Reveal the card
		cardsToShuffle[index].src = cardsToShuffle[index].getAttribute("front");
		//Put it handYOffset below the deck and handXOffset to the right
		cardsToShuffle[index].style.top = numCardsLeftInDeck + cardHeight + deckYOffset + handYOffset + 'px';
		cardsToShuffle[index].style.left = xEndOfDeck + handXOffset + i * (cardWidth + cardSeparation) + 'px';
		cardsToShuffle[index].className = cardsToShuffle[index].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToShuffle[index].parentNode.appendChild(cardsToShuffle[index]);
		//Remove it from the list of cards to be shuffled
		cardsToShuffle.splice(index,1);
	}

	//Shuffle the remaining cards
	for (; i < numCards; ++i)
	{
		//Select a card at random
		var index = Math.floor(Math.random() * cardsToShuffle.length);
		//Conceal the card
		cardsToShuffle[index].src = document.getElementById("card sleeve image").value;
		//Put it into the deck
		cardsToShuffle[index].style.top = deckYOffset + (i - handSize) + 'px';
		cardsToShuffle[index].style.left = deckXOffset + (i - handSize) + 'px';
		cardsToShuffle[index].className = cardsToShuffle[index].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToShuffle[index].parentNode.appendChild(cardsToShuffle[index]);
		//Remove it from the list of cards to be shuffled
		cardsToShuffle.splice(index,1);
	}

	var xEndOfHand = xEndOfDeck + handXOffset + 7 * (cardWidth + cardSeparation);

	addCounter(parseInt(document.getElementById("starting life").value) || 20, xEndOfDeck + cardSeparation + lifeCounterXOffset, lifeCounterYOffset);
	addCounter(parseInt(document.getElementById("starting life").value) || 20, xEndOfDeck + cardSeparation + lifeCounterXOffset + 100, lifeCounterYOffset);

	//Sort the tokens by cost
	tokensToStack.sort(
		function(a,b){
			var ret = getTotalCost(a) - getTotalCost(b);
			if (ret == 0)
			{
				ret = getColorOrder(a) - getColorOrder(b);
				if (ret == 0)
				{
					var aName = a.getAttribute("name");
					var bName = b.getAttribute("name");
					if (aName != null && bName != null)
					{
						ret = aName.localeCompare(bName);
					} else {
						ret = 0;
					}
				}
			}
			return ret;
		}
	);

	//Sort the commanders by cost
	commandersToStack.sort(
		function(a,b){
			var ret = getTotalCost(a) - getTotalCost(b);
			if (ret == 0)
			{
				ret = getColorOrder(a) - getColorOrder(b);
				if (ret == 0)
				{
					var aName = a.getAttribute("name");
					var bName = b.getAttribute("name");
					if (aName != null && bName != null)
					{
						ret = aName.localeCompare(bName);
					} else {
						ret = 0;
					}
				}
			}
			return ret;
		}
	);

	//Stack the commanders (if any)
	var xEndOfCommanders = xEndOfHand;
	if (commandersToStack.length > 0)
	{
		xEndOfCommanders = xEndOfHand + cardSeparation + cardWidth;
		for( i = 0; i < commandersToStack.length; ++i)
		{
			//Reveal the card
			commandersToStack[i].src = commandersToStack[i].getAttribute("front");
			//Move it
			commandersToStack[i].style.top = commanderYOffset + i * (cardHeight + cardSeparation) + 'px';
			commandersToStack[i].style.left = xEndOfHand + cardSeparation + 'px';
			//Untap it
			commandersToStack[i].className = commandersToStack[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
			//Bring it in front of the other elements
			commandersToStack[i].parentNode.appendChild(commandersToStack[i]);
		}
	}

	//Stack the tokens
	for( i = 0; i < tokensToStack.length; ++i)
	{
		//Reveal the card
		tokensToStack[i].src = tokensToStack[i].getAttribute("front");
		//Move it
		tokensToStack[i].style.top = tokensYOffset + i * nameHeight + 'px';
		tokensToStack[i].style.left = xEndOfCommanders + cardSeparation + 'px';
		//Untap it
		tokensToStack[i].className = tokensToStack[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		tokensToStack[i].parentNode.appendChild(tokensToStack[i]);
	}

	//Resize document to fit
	resizeDocument();
}

function toggleSideboard()
{
	var sideboard = document.getElementById('sideboard');
	if (sideboard.style.visibility == 'visible')
	{
		sideboard.style.visibility = 'hidden';
		document.getElementById('toggle sideboard button').innerHTML = "Show Sideboard";
	} else {
		sideboard.style.visibility = 'visible';
		document.getElementById('toggle sideboard button').innerHTML = "Hide Sideboard";
	}
}

function stack()
{
	//Are any cards selected?
	var elementsToStack = document.getElementById('selector').getElementsByTagName('*');

	//Figure out which of the elements are non-commander cards
	var cardsToStack = [];
	var i = 0;
	for (i = 0; i < elementsToStack.length; ++i)
	{
		if (hasClass(elementsToStack[i], "card") )
		{
			cardsToStack.push(elementsToStack[i]);
		}
	}

	//Stack the cards
	var xOffset = 0;
	var yOffset = 0;
	
	
	for (i = 0; i < cardsToStack.length; ++i)
	{
		//Put it into the stack
		cardsToStack[i].style.top = yOffset + 'px';
		cardsToStack[i].style.left = xOffset + 'px';
		//Is this card concealed?
		if (cardsToStack[i].src == document.getElementById("card sleeve image").value)
		{
			xOffset = xOffset + 1;
			yOffset = yOffset + 1;
		} else {
			yOffset = yOffset + nameHeight;
		}
	}

	//Resize document to fit
	resizeDocument();
}

var ManaCost = function(manaCostString)
{
	this.generic = 0;
	this.w = 0;
	this.u = 0;
	this.b = 0;
	this.r = 0;
	this.g = 0;
	this.c = 0;
	this.wu = 0;
	this.ub = 0;
	this.br = 0;
	this.rg = 0;
	this.gw = 0;
	this.wb = 0;
	this.ur = 0;
	this.bg = 0;
	this.rw = 0;
	this.gu = 0;
	this.total = 0;
	this.colorBitVector = 0;
	this.coloredSymbolBitVectors = [];

	if(manaCostString != null)
	{
		var lc_manaCostString = manaCostString.toLowerCase();
		for (var c = 0; c < lc_manaCostString.length; ++c)
		{
			//Is this character a number?
			if (lc_manaCostString.charCodeAt(c) >= "0".charCodeAt(0) &&
				lc_manaCostString.charCodeAt(c) <= "9".charCodeAt(0))
			{
				//Add this digit to the running generic mana cost
				this.generic = this.generic * 10 + lc_manaCostString.charCodeAt(c) - "0".charCodeAt(0);
			} else if (lc_manaCostString[c] == 'w') {
				this.w++;
				this.colorBitVector |= 0x01;
				this.coloredSymbolBitVectors.push(0x01);
			} else if (lc_manaCostString[c] == 'u') {
				this.u++;
				this.colorBitVector |= 0x02;
				this.coloredSymbolBitVectors.push(0x02);
			} else if (lc_manaCostString[c] == 'b') {
				this.b++;
				this.colorBitVector |= 0x04;
				this.coloredSymbolBitVectors.push(0x04);
			} else if (lc_manaCostString[c] == 'r') {
				this.r++;
				this.colorBitVector |= 0x08;
				this.coloredSymbolBitVectors.push(0x08);
			} else if (lc_manaCostString[c] == 'g') {
				this.g++;
				this.colorBitVector |= 0x10;
				this.coloredSymbolBitVectors.push(0x10);
			} else if (lc_manaCostString[c] == 'c') {
				this.c++;
				this.colorBitVector |= 0x20;
				this.coloredSymbolBitVectors.push(0x20);
			} else if (lc_manaCostString[c] == '{' && (c+5) <= lc_manaCostString.length) {
				var substring = lc_manaCostString.substring(c,c+5);
				if ( substring       == "{w/u}") {
					this.wu++;
					this.colorBitVector |= 0x03;
					this.coloredSymbolBitVectors.push(0x03);
				} else if (substring == "{u/b}") {
					this.ub++;
					this.colorBitVector |= 0x06;
					this.coloredSymbolBitVectors.push(0x06);
				} else if (substring == "{b/r}") {
					this.br++;
					this.colorBitVector |= 0x0C;
					this.coloredSymbolBitVectors.push(0x0C);
				} else if (substring == "{r/g}") {
					this.rg++;
					this.colorBitVector |= 0x18;
					this.coloredSymbolBitVectors.push(0x18);
				} else if (substring == "{g/w}") {
					this.gw++;
					this.colorBitVector |= 0x11;
					this.coloredSymbolBitVectors.push(0x11);
				} else if (substring == "{w/b}") {
					this.wb++;
					this.colorBitVector |= 0x05;
					this.coloredSymbolBitVectors.push(0x05);
				} else if (substring == "{u/r}") {
					this.ur++;
					this.colorBitVector |= 0x0A;
					this.coloredSymbolBitVectors.push(0x0A);
				} else if (substring == "{b/g}") {
					this.bg++;
					this.colorBitVector |= 0x14;
					this.coloredSymbolBitVectors.push(0x14);
				} else if (substring == "{r/w}") {
					this.rw++;
					this.colorBitVector |= 0x09;
					this.coloredSymbolBitVectors.push(0x09);
				} else if (substring == "{g/u}") {
					this.gu++;
					this.colorBitVector |= 0x12;
					this.coloredSymbolBitVectors.push(0x12);
				}
				c += 4;
			}
		}
		this.total = this.generic + this.w + this.u + this.b + this.r + this.g + this.c + this.wu + this.ub + this.br + this.rg + this.gw + this.wb + this.ur + this.bg + this.rw + this.gu;
	}
}

function manaCostsAreEqual(a, b)
{
	if (a.total != b.total ||
		a.generic != b.generic ||
		a.w != b.w ||
		a.u != b.u ||
		a.b != b.b ||
		a.r != b.r ||
		a.g != b.g ||
		a.wu != b.wu ||
		a.ub != b.ub ||
		a.br != b.br ||
		a.rg != b.rg ||
		a.gw != b.gw ||
		a.wb != b.wb ||
		a.ur != b.ur ||
		a.bg != b.bg ||
		a.rw != b.rw ||
		a.gu != b.gu
		)
	{
		return false;
	} else {
		return true;
	}
}

function getTotalCost(cardElement)
{
	if (cardElement.getAttribute('token') == 'true')
	{
		return 1000000000000;
	} else if (cardElement.getAttribute('land') == 'true') {
		return -1;
	} else {
		var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
		return cost.total;
	}
}

function getTotalCostLabel(cardElement)
{
	if (cardElement.getAttribute('token') == 'true')
	{
		return "Token";
	} else if (cardElement.getAttribute('land') == 'true') {
		return "Land";
	} else {
		var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
		return String(cost.total) + " Mana";
	}
}

colorOrderLookupTable = [ 1,  2,  3,  7,  4, 12,  8, 17, 5, 16, 15, 22,  9, 24, 18, 31, 6, 11, 14, 21, 13, 26, 23, 30, 10, 20, 25, 29, 19, 28, 27, 32, 33, 34, 35, 39, 36, 44, 40, 49, 37, 48, 47, 54, 41, 56, 50, 63, 38, 43, 46, 53, 45, 58, 55, 62, 42, 52, 57, 61, 51, 60, 59, 64];


function getColorOrder(cardElement)
{
	if (cardElement.getAttribute('token') == 'true')
	{
		return 65;
	}
	else if (cardElement.getAttribute('land') == 'true')
	{
		var manaProductionBitVector = parseInt(cardElement.getAttribute('mana_production_bitvector'));
		//Ignore colorless production
		if (manaProductionBitVector >= 32)
		{
			manaProductionBitVector = manaProductionBitVector - 32;
		}
		//Lands come after nonlands
		return (colorOrderLookupTable[manaProductionBitVector] + 100);
	} else {
		var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
		return colorOrderLookupTable[cost.colorBitVector];
	}
}

function getColorLabel(cardElement)
{
	if (cardElement.getAttribute('token') == 'true')
	{
		return 'Token';
	}
	else if (cardElement.getAttribute('land') == 'true')
	{
		var manaProductionBitVector = parseInt(cardElement.getAttribute('mana_production_bitvector'));
		var colorLabelString = "";
		if (manaProductionBitVector & 0x01){colorLabelString += 'W';}
		if (manaProductionBitVector & 0x02){colorLabelString += 'U';}
		if (manaProductionBitVector & 0x04){colorLabelString += 'B';}
		if (manaProductionBitVector & 0x08){colorLabelString += 'R';}
		if (manaProductionBitVector & 0x10){colorLabelString += 'G';}
		if (colorLabelString == ""){colorLabelString += 'C';}

		colorLabelString += ' Land';
		return colorLabelString;
	} else {
		var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
		var colorLabelString = "";
		if (cost.colorBitVector & 0x01){colorLabelString += 'W';}
		if (cost.colorBitVector & 0x02){colorLabelString += 'U';}
		if (cost.colorBitVector & 0x04){colorLabelString += 'B';}
		if (cost.colorBitVector & 0x08){colorLabelString += 'R';}
		if (cost.colorBitVector & 0x10){colorLabelString += 'G';}
		if (cost.colorBitVector & 0x20){colorLabelString += 'C';}
		if (colorLabelString == ""){colorLabelString = "Generic";}
		return colorLabelString;
	}
}

function getTypeOrder(cardElement)
{
	if (cardElement.getAttribute('token') == 'true') {
		return 7;
	} else if (cardElement.getAttribute('land') == 'true') {
		return -1;
	} else if (cardElement.getAttribute('creature') == 'true') {
		return 1;
	} else if (cardElement.getAttribute('planeswalker') == 'true') {
		return 2;
	} else if (cardElement.getAttribute('artifact') == 'true') {
		return 3;
	} else if (cardElement.getAttribute('enchantment') == 'true') {
		return 4;
	} else if (cardElement.getAttribute('sorcery') == 'true') {
		return 5;
	} else if (cardElement.getAttribute('instant') == 'true') {
		return 6;
	} else {
		return 8;
	}
}

function getTypeLabel(cardElement)
{
	if (cardElement.getAttribute('token') == 'true') {
		return 'Token';
	} else if (cardElement.getAttribute('land') == 'true') {
		return 'Land';
	} else if (cardElement.getAttribute('creature') == 'true') {
		return 'Creature';
	} else if (cardElement.getAttribute('planeswalker') == 'true') {
		return 'Planeswalker';
	} else if (cardElement.getAttribute('artifact') == 'true') {
		return 'Artifact';
	} else if (cardElement.getAttribute('enchantment') == 'true') {
		return 'Enchantment';
	} else if (cardElement.getAttribute('sorcery') == 'true') {
		return 'Sorcery';
	} else if (cardElement.getAttribute('instant') == 'true') {
		return 'Instant';
	} else {
		return'Unknown';
	}
}

function getPurposeLabel(cardElement)
{
	var purpose = cardElement.getAttribute('purpose');
	if (purpose == null || purpose == "")
	{
		purpose = getTypeLabel(cardElement);
	}
	return purpose;
}

function dumpSideboard()
{
	//Get all the elements in the sideboard
	var sideboard = document.getElementById('sideboard');
	var playmat = document.getElementById('playmat');
	var elementsInSideboard = sideboard.getElementsByTagName('*');
	var rect = sideboard.getBoundingClientRect();
	var i = 0;
	while (elementsInSideboard.length > 0)
	{
		//Remove sideboarded class
		elementsInSideboard[0].className = elementsInSideboard[0].className.replace( /(?:^|\s)sideboarded(?!\S)/g , '' );
		//Put it on the playmat
		elementsInSideboard[0].style.top = 10 + getScrollY() + rect.top + i * nameHeight + 'px';
		elementsInSideboard[0].style.left= 10 + getScrollX() + rect.left + 'px'; //TODO
		playmat.appendChild(elementsInSideboard[0]);
		++i;
	}
}

function sortSideboard()
{
	//Get all the elements in the sideboard
	var elementsOnSideboard = document.getElementById('sideboard').getElementsByTagName('*');
	
	//Figure out which of the elements are cards
	var cardsToSort = [];
	var i = 0;
	for (i = 0; i < elementsOnSideboard.length; ++i)
	{
		if (hasClass(elementsOnSideboard[i], "card"))
		{
			cardsToSort.push(elementsOnSideboard[i]);
		}
	}

	//Sort the cards by cost
	cardsToSort.sort(
		function(a,b)
		{
			var ret = getColorOrder(a) - getColorOrder(b);
			if (ret == 0)
			{
				ret = getTotalCost(a) - getTotalCost(b);
				if (ret == 0)
				{
					var aName = a.getAttribute("name");
					var bName = b.getAttribute("name");
					if (aName != null && bName != null)
					{
						ret = aName.localeCompare(bName);
					} else {
						ret = 0;
					}
				}
			}
			return ret;
		}
	);

	var xOffset = 10;
	var yOffset = 10;

	for (i = 0; i < cardsToSort.length; ++i)
	{
		//Reveal the card
		cardsToSort[i].src = cardsToSort[i].getAttribute("front");
		//Put it into the deck
		cardsToSort[i].style.top = yOffset + nameHeight * i + 'px';
		cardsToSort[i].style.left = xOffset + 'px';
		//Untap
		cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
	}
}

function costSort()
{
	//Deselect any selected cards
	deselectAll();
	deleteAllCounters();
	deleteAllLabels();;

	//Get all the elements on the playmat
	var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

	//Figure out which of the elements are cards
	var totalNontokenCards = 0;
	var cardsToSort = [];
	var i = 0;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		if (hasClass(elementsOnMat[i], "card"))
		{
			if (elementsOnMat[i].getAttribute("token") != 'true')
			{
				++totalNontokenCards;
			}
			cardsToSort.push(elementsOnMat[i]);
		}
	}

	//Label the size of the previous stack
	var totalSizelabel = Label("Total: " + String(totalNontokenCards));
	totalSizelabel.style.left = 0 + 'px';
	totalSizelabel.style.top = toolbarHeight + 30 + 'px';

	//Sort the cards by cost
	cardsToSort.sort(
		function(a,b){
			var ret = getTotalCost(a) - getTotalCost(b);
			if (ret == 0)
			{
				ret = getColorOrder(a) - getColorOrder(b);
				if (ret == 0)
				{
					var aName = a.getAttribute("name");
					var bName = b.getAttribute("name");
					if (aName != null && bName != null)
					{
						ret = aName.localeCompare(bName);
					} else {
						ret = 0;
					}
				}
			}
			return ret;
		}
	);

	//Arrange the cards on the mat
	var stackNum = 0;
	var previousCardValue = -9000;
	var stackHeight = 0;

	var xOffset = 50;
	var yOffset = 130 + toolbarHeight;

	var stackSpacing = cardWidth + 10;

	for (i = 0; i < cardsToSort.length; ++i)
	{
		//Is this card of a different class?
		if (getTotalCost(cardsToSort[i]) != previousCardValue)
		{
			//Is this the end of a stack?
			if (stackHeight > 0)
			{
				//Label the size of the previous stack
				var sizelabel = Label(String(stackHeight));
				sizelabel.style.top = yOffset - 60 + 'px';
				sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			}

			//Create a new stack
			stackNum++;
			stackHeight = 0;
			var label = Label(getTotalCostLabel(cardsToSort[i]));
			label.style.top = yOffset - 30 + 'px';
			label.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			previousCardValue = getTotalCost(cardsToSort[i]);
		}
		//Add this card to the stack
		//Reveal the card
		cardsToSort[i].src = cardsToSort[i].getAttribute("front");
		//Put it into the deck
		cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
		cardsToSort[i].style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
		//Untap
		cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
		stackHeight++;
	}

	//Is this the end of a stack?
	if (stackHeight > 0)
	{
		//Label the size of the previous stack
		var sizelabel = Label(String(stackHeight));
		sizelabel.style.top = yOffset - 60 + 'px';
		sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
	}

	//Resize document to fit
	resizeDocument();
}

function typeSort()
{
	//Deselect any selected cards
	deselectAll();
	deleteAllCounters();
	deleteAllLabels();

	//Get all the elements on the playmat
	var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

	//Figure out which of the elements are cards
	var totalNontokenCards = 0;
	var cardsToSort = [];
	var i = 0;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		if (hasClass(elementsOnMat[i], "card"))
		{
			if (elementsOnMat[i].getAttribute("token") != 'true')
			{
				++totalNontokenCards;
			}
			cardsToSort.push(elementsOnMat[i]);
		}
	}

	//Label the size of the previous stack
	var totalSizelabel = Label("Total: " + String(totalNontokenCards));
	totalSizelabel.style.left = 0 + 'px';
	totalSizelabel.style.top = 30 + toolbarHeight + 'px';

	//Sort the cards by type, then cost, then color, then name
	cardsToSort.sort(
		function(a,b){
			var ret = getTypeOrder(a) - getTypeOrder(b);
			if (ret == 0)
			{
				ret = getTotalCost(a) - getTotalCost(b);
				if (ret == 0)
				{
					ret = getColorOrder(a) - getColorOrder(b);
					if (ret == 0)
					{
						var aName = a.getAttribute("name");
						var bName = b.getAttribute("name");
						if (aName != null && bName != null)
						{
							ret = aName.localeCompare(bName);
						} else {
							ret = 0;
						}
					}
				}
			}
			return ret;
		}
	);

	//Arrange the cards on the mat
	var stackNum = 0;
	var previousCardValue = -9000;
	var stackHeight = 0;

	var xOffset = 50;
	var yOffset = 130 + toolbarHeight;

	var stackSpacing = cardWidth + 10;

	for (i = 0; i < cardsToSort.length; ++i)
	{
		//Is this card of a different class?
		if (getTypeOrder(cardsToSort[i]) != previousCardValue)
		{
			//Is this the end of a stack?
			if (stackHeight > 0)
			{
				//Label the size of the previous stack
				var sizelabel = Label(String(stackHeight));
				sizelabel.style.top = yOffset - 60 + 'px';
				sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			}
			//Create a new stack
			stackNum++;
			stackHeight = 0;
			var label = Label(getTypeLabel(cardsToSort[i]));
			label.style.top = yOffset - 30 + 'px';
			label.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			previousCardValue = getTypeOrder(cardsToSort[i]);
		}
		//Add this card to the stack
		//Reveal the card
		cardsToSort[i].src = cardsToSort[i].getAttribute("front");
		//Put it into the deck
		cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
		cardsToSort[i].style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
		//Untap
		cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
		stackHeight++;
	}
	//Is this the end of a stack?
	if (stackHeight > 0)
	{
		//Label the size of the previous stack
		var sizelabel = Label(String(stackHeight));
		sizelabel.style.top = yOffset - 60 + 'px';
		sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
	}

	//Resize document to fit
	resizeDocument();
}

function colorSort()
{
	//Deselect any selected cards
	deselectAll();
	deleteAllCounters();
	deleteAllLabels();

	//Get all the elements on the playmat
	var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

	//Figure out which of the elements are cards
	var totalNontokenCards = 0;
	var cardsToSort = [];
	var i = 0;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		if (hasClass(elementsOnMat[i], "card"))
		{
			if (elementsOnMat[i].getAttribute("token") != 'true')
			{
				++totalNontokenCards;
			}
			cardsToSort.push(elementsOnMat[i]);
		}
	}

	//Label the size of the previous stack
	var totalSizelabel = Label("Total: " + String(totalNontokenCards));
	totalSizelabel.style.left = 0 + 'px';
	totalSizelabel.style.top = 30 + toolbarHeight + 'px';

	//Sort the cards by color, then cost, then name
	cardsToSort.sort(
		function(a,b)
		{
			var ret = getColorOrder(a) - getColorOrder(b);
			if (ret == 0)
			{
				ret = getTotalCost(a) - getTotalCost(b);
				if (ret == 0)
				{
					var aName = a.getAttribute("name");
					var bName = b.getAttribute("name");
					if (aName != null && bName != null)
					{
						ret = aName.localeCompare(bName);
					} else {
						ret = 0;
					}
				}
			}
			return ret;
		}
	);

	//Figure out the necessary columns
	var columns = [];
	for (i = 0; i < 65; ++i)
	{
		columns.push(-1);
	}

	function getColumnId(colorOrder)
	{
		colorOrder = colorOrder - 1;
		if (colorOrder >= 100) {
			return colorOrder - 100;
		} else {
			return colorOrder;
		}
	}

	//Figure out which columns will have cards
	for (i = 0; i < cardsToSort.length; ++i)
	{
		columns[getColumnId(getColorOrder(cardsToSort[i]))] = 1;
	}

	//Number off the columns that have cards
	var columnNum = 0;
	for (i = 0; i < columns.length; ++i)
	{
		if (columns[i] == 1){
			columns[i] = columnNum;
			columnNum++;
		}
	}

	//Arrange the cards on the mat
	var previousCardValue = -9000;
	var row1Height = 0;
	var stackHeight = 0;
	var xOffset = 50;
	var yOffset = 130 + toolbarHeight;
	var stackSpacing = cardWidth + 10;

	for (i = 0; i < cardsToSort.length; ++i)
	{
		//Is this card of a different color?
		if ( getColorOrder(cardsToSort[i]) != previousCardValue )
		{
			//Is this the end of a stack?
			if (stackHeight > 0)
			{
				//Label the size of the previous stack
				var sizelabel = Label(String(stackHeight));
				sizelabel.style.left = xOffset + stackSpacing * columns[getColumnId(getColorOrder(cardsToSort[i - 1]))] + 'px';
				if (getColorOrder(cardsToSort[i-1]) < 100)
				{
					sizelabel.style.top = yOffset - 60 + 'px';
				} else {
					sizelabel.style.top = yOffset + cardsToSort[i-1].clientHeight + nameHeight * row1Height + 60 - 60 + 'px';
				}
			}
			//Create a new stack
			stackHeight = 0;
			//Label it
			var label = Label(getColorLabel(cardsToSort[i]));
			label.style.left = xOffset + stackSpacing * columns[getColumnId(getColorOrder(cardsToSort[i]))] + 'px';
			if (getColorOrder(cardsToSort[i]) < 100)
			{
				label.style.top = yOffset + nameHeight * stackHeight - 30 + 'px';
			} else {
				label.style.top = yOffset + cardsToSort[i].clientHeight + nameHeight * row1Height + 60 - 30 + 'px';
			}
			previousCardValue = getColorOrder(cardsToSort[i]);
		}
		
		//Add this card to the stack
		//Reveal the card
		cardsToSort[i].src = cardsToSort[i].getAttribute("front");
		//Put it in its column
		cardsToSort[i].style.left = xOffset + stackSpacing * columns[getColumnId(getColorOrder(cardsToSort[i]))] + 'px';
		//Untap
		cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		
		//Check if this is part of row 1
		if ( getColorOrder(cardsToSort[i]) < 100 )
		{
			cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
			stackHeight++;
			//Save the height of the largest stack in row 1
			if (stackHeight > row1Height)
			{
				row1Height = stackHeight;
			}
		} else {
			cardsToSort[i].style.top = yOffset + cardsToSort[i].clientHeight +  nameHeight * row1Height + nameHeight * stackHeight + 60 + 'px';
			stackHeight++;
		}

		//Bring it in front of the other elements
		cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
	}
	//Is this the end of a stack?
	if (stackHeight > 0)
	{
		//Label the size of the previous stack
		var sizelabel = Label(String(stackHeight));
		sizelabel.style.left = xOffset + stackSpacing * columns[getColumnId(getColorOrder(cardsToSort[i - 1]))] + 'px';
		if (getColorOrder(cardsToSort[i-1]) < 100)
		{
			sizelabel.style.top = yOffset - 60 + 'px';
		} else {
			sizelabel.style.top = yOffset + cardsToSort[i-1].clientHeight + nameHeight * row1Height + 60 - 60 + 'px';
		}
	}

	//Resize document to fit
	resizeDocument();
}

function purposeSort()
{
	//Deselect any selected cards
	deselectAll();
	deleteAllCounters();
	deleteAllLabels();

	//Get all the elements on the playmat
	var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

	//Figure out which of the elements are cards
	var totalNontokenCards = 0;
	var cardsToSort = [];
	var i = 0;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		if (hasClass(elementsOnMat[i], "card"))
		{
			if (elementsOnMat[i].getAttribute("token") != 'true')
			{
				++totalNontokenCards;
			}
			cardsToSort.push(elementsOnMat[i]);
		}
	}

	//Label the size of the previous stack
	var totalSizelabel = Label("Total: " + String(totalNontokenCards));
	totalSizelabel.style.left = 0 + 'px';
	totalSizelabel.style.top = 30 + toolbarHeight + 'px';

	//Sort the cards by purpose, then cost, then color, then name
	cardsToSort.sort(
		function(a,b){
			var aPurpose = getPurposeLabel(a);
			var bPurpose = getPurposeLabel(b);

			if (aPurpose == "Land" && bPurpose != "Land")
			{
				ret = -1;
			} else if (bPurpose == "Land" && aPurpose != "Land") {
				ret = 1;
			} else if (aPurpose == "Token" && bPurpose != "Token") {
				ret = 1;
			} else if (bPurpose == "Token" && aPurpose != "Token") {
				ret = -1;
			} else {
				ret = aPurpose.localeCompare(bPurpose);
			}
			if (ret == 0)
			{
				ret = getTotalCost(a) - getTotalCost(b);
				if (ret == 0)
				{
					ret = getColorOrder(a) - getColorOrder(b);
					if (ret == 0)
					{
						var aName = a.getAttribute("name");
						var bName = b.getAttribute("name");
						if (aName != null && bName != null)
						{
							ret = aName.localeCompare(bName);
						} else {
							ret = 0;
						}
					}
				}
			}
			return ret;
		}
	);

	//Arrange the cards on the mat
	var stackNum = 0;
	var previousCardValue = "plumbus"; //Who knows what its purpose is...
	var stackHeight = 0;

	var xOffset = 50;
	var yOffset = 130 + toolbarHeight;

	var stackSpacing = cardWidth + 10;

	for (i = 0; i < cardsToSort.length; ++i)
	{
		//Is this card of a different class?
		if (getPurposeLabel(cardsToSort[i]) != previousCardValue)
		{
			//Is this the end of a stack?
			if (stackHeight > 0)
			{
				//Label the size of the previous stack
				var sizelabel = Label(String(stackHeight));
				sizelabel.style.top = yOffset - 60 + 'px';
				sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			}
			//Create a new stack
			stackNum++;
			stackHeight = 0;
			var label = Label(getPurposeLabel(cardsToSort[i]));
			label.style.top = yOffset - 30 + 'px';
			label.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			previousCardValue = getPurposeLabel(cardsToSort[i]);
		}
		//Add this card to the stack
		//Reveal the card
		cardsToSort[i].src = cardsToSort[i].getAttribute("front");
		//Put it into the deck
		cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
		cardsToSort[i].style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
		//Untap
		cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
		stackHeight++;
	}
	//Is this the end of a stack?
	if (stackHeight > 0)
	{
		//Label the size of the previous stack
		var sizelabel = Label(String(stackHeight));
		sizelabel.style.top = yOffset - 60 + 'px';
		sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
	}

	//Resize document to fit
	resizeDocument();
}

function curvabilitySort()
{
	//Deselect any selected cards
	deselectAll();
	deleteAllCounters();
	deleteAllLabels();

	//Get all the elements on the playmat
	var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

	//Figure out which of the elements are cards
	//Also compute their curvability
	var cardsWithUniqueCosts = [];
	var curvabilityOfCardsWithUniqueCosts = [];
	var totalNontokenCards = 0;
	var cardsToSort = [];
	var i = 0;
	var j = 0;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		if (hasClass(elementsOnMat[i], "card"))
		{
			if (elementsOnMat[i].getAttribute("token") != 'true')
			{
				++totalNontokenCards;
			}
			cardsToSort.push(elementsOnMat[i]);
			//Check if this card isn't a land
			if (elementsOnMat[i].getAttribute("land") != 'true')
			{
				//Check if this card has a new cost
				var unique = true;
				for (j = 0; j < cardsWithUniqueCosts.length; ++j)
				{
					//Check if both of these cards are commanders or both not commanders
					if (cardsWithUniqueCosts[j].getAttribute('commander') == elementsOnMat[i].getAttribute('commander'))
					{
						//Check if they have the same cost
						var costA = new ManaCost(cardsWithUniqueCosts[j].getAttribute('casting_cost'));
						var costB = new ManaCost(elementsOnMat[i].getAttribute('casting_cost'));
						if (manaCostsAreEqual(costA, costB))
						{
							//Not unique
							unique = false;
						}
					}
				}
				//If the card has a unique cost
				if (unique)
				{
					//Add it
					cardsWithUniqueCosts.push(elementsOnMat[i]);
					//Compute the probability you can cast it on curve
					var curvability = computeCurveCastingProbabilityOfCard(elementsOnMat[i]);
					curvabilityOfCardsWithUniqueCosts.push(curvability);
					//console.log(elementsOnMat[i].getAttribute('name') + ": " + curvability * 100);
				}
			}
		}
	}

	//Create a label for the total number of cards
	var totalSizelabel = Label("Total: " + String(totalNontokenCards));
	totalSizelabel.style.left = 0 + 'px';
	totalSizelabel.style.top = 30 + toolbarHeight + 'px';

	function getCurvability(cardElement)
	{
		//Check that this isn't a land
		if (cardElement.getAttribute('token') == 'true')
		{
			return -100; //Tokens are super duper curvable
		}
		else if (cardElement.getAttribute('land') == 'true')
		{
			return 200; //Lands are super duper curvable
		} else {
			var j = 0;
			for (j = 0; j < cardsWithUniqueCosts.length; ++j)
			{
				//Check if both of these cards are commanders or both not commanders
				if (cardsWithUniqueCosts[j].getAttribute('commander') == cardElement.getAttribute('commander'))
				{
					//Check if they have the same cost
					var costA = new ManaCost(cardsWithUniqueCosts[j].getAttribute('casting_cost'));
					var costB = new ManaCost(cardElement.getAttribute('casting_cost'));
					if (manaCostsAreEqual(costA, costB))
					{
						//Found it
						return curvabilityOfCardsWithUniqueCosts[j];
					}
				}
			}
			return -1; 	//This shouldn't happen
		}
	}

	/*for (i = 0; i < cardsToSort.length; ++i)
	{
		console.log(cardsToSort[i].getAttribute("name") + ": " + getCurvability(cardsToSort[i]));
	}*/

	//Sort the cards by curvability
	cardsToSort.sort(
		function(a,b){
			//Compare their curvability descending order
			var ret = getCurvability(b) - getCurvability(a);
			if (ret == 0)
			{
				ret = getColorOrder(a) - getColorOrder(b);
				if (ret == 0)
				{
					var aName = a.getAttribute("name");
					var bName = b.getAttribute("name");
					if (aName != null && bName != null)
					{
						ret = aName.localeCompare(bName);
					} else {
						ret = 0;
					}
				}
			}
			return ret;
		}
	);

	//Arrange the cards on the mat
	var stackNum = 0;
	var previousCardValue = -9000;
	var stackHeight = 0;

	var xOffset = 50;
	var yOffset = 130 + toolbarHeight;

	var stackSpacing = cardWidth + 10;

	for (i = 0; i < cardsToSort.length; ++i)
	{
		//Is this card of a different class?
		var curvability = getCurvability(cardsToSort[i]);
		if (curvability != previousCardValue)
		{
			//Is this the end of a stack?
			if (stackHeight > 0)
			{
				//Label the size of the previous stack
				var sizelabel = Label(String(stackHeight));
				sizelabel.style.top = yOffset - 60 + 'px';
				sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			}

			//Create a new stack
			stackNum++;
			stackHeight = 0;
			if (curvability == 200)
			{
				var label = Label("Lands");
			} else if (curvability == -100) {
				var label = Label("Tokens");
			} else {
				var label = Label(Math.round(curvability * 10000)/100 + "%");
				if (curvability < 0.5)
				{
					label.style.color = 'red';
				} else if (curvability < 0.6) {
					label.style.color = 'orange';
				} else if (curvability < 0.7) {
					label.style.color = 'yellow';
				} else if (curvability < 0.8) {
					label.style.color = 'green';
				} else if (curvability < 0.9) {
					label.style.color = 'rgb(0, 46, 255)';
				} else {
					label.style.color = 'purple';
				}
			}
			label.style.top = yOffset - 30 + 'px';
			label.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
			previousCardValue = curvability;
		}
		//Add this card to the stack
		//Reveal the card
		cardsToSort[i].src = cardsToSort[i].getAttribute("front");
		//Put it into the deck
		cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
		cardsToSort[i].style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
		//Untap
		cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
		//Bring it in front of the other elements
		cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
		stackHeight++;
	}

	//Is this the end of a stack?
	if (stackHeight > 0)
	{
		//Label the size of the previous stack
		var sizelabel = Label(String(stackHeight));
		sizelabel.style.top = yOffset - 60 + 'px';
		sizelabel.style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
	}

	//Resize document to fit
	resizeDocument();
}

function deleteSelection()
{

	document.getElementById('magnified card view').src = "";
	hideCardInfoMenu();
	
	//Get all the elements in the selection
	var elementsInSelection = document.getElementById('selector').getElementsByTagName('*');

	//Delete all the elements
	var elementsToDelete = [];
	for (i = 0; i < elementsInSelection.length; ++i)
	{
		elementsToDelete.push(elementsInSelection[i]);
	}

	for (i = 0; i < elementsToDelete.length; ++i)
	{
		elementsToDelete[i].parentNode.removeChild(elementsToDelete[i]);
	}

	deselectAll();
}

//Precompute binomial coefficients for dat speed
var pascalsTriangle = [[1]];
function computePascalsTriangleUpTo( nn )
{
	//For each row
	var n = pascalsTriangle.length;
	for (n = pascalsTriangle.length; n <= nn; ++n)
	{
		var row = [];
		row.push(1);
		var k = 1;
		for (k = 1; k < n; ++k)
		{
			row.push(pascalsTriangle[n-1][k-1] + pascalsTriangle[n-1][k]);
		}
		row.push(1);
		pascalsTriangle.push(row);
	}
}

function nChooseK(n,k)
{
	if (k > n)
	{
		return 0;
	} else if (k < 0) {
		return 0;
	} else if (n < 0) {
		return 0;
	} else {
		return pascalsTriangle[n][k];
	}
}

//Given a deck of nn cards, m of which are cards you want. What is the probability that if you draw n cards, x are the kind you want?
function hypergeometricDistribution(successesInSample, successesInPopulation, sampleSize, populationSize) {
	computePascalsTriangleUpTo(populationSize);
	return nChooseK(successesInPopulation, successesInSample) * nChooseK(populationSize - successesInPopulation, sampleSize - successesInSample) / nChooseK(populationSize, sampleSize);
}

//A class to represent a set of lands that can all produce the same mana. (How many UW duals do I have?)
var LandCount = function(manaProductionBitVector)
{
	this.manaProductionBitVector = manaProductionBitVector;
	this.count = 1;
}

var maxNumLands = 18;
function computeCastingProbabilitiesOfCard(cardElement)
{
	//console.log("Name: " +cardElement.getAttribute('name'));
	//Get the cost of the currently selected card
	var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
	//console.log("Total Cost: " + cost.total);
	//Get whether this card is a commander
	var isCommander = cardElement.getAttribute('commander') == 'true';
	//console.log("Is Commander: " + cardElement.getAttribute('commander'));
	//Count how many non-commander non-token cards are on the playmat.
	var numCardsInDeck = 0;
	var numUsefulLandsInDeck = 0;
	//Also count the mana production available
	var manaProduction = [];

	//Get all the elements on the playmat
	var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

	//Figure out which of the elements are cards
	var i = 0;
	var j = 0;
	var k = 0;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		//Check that the element is a card
		if (hasClass(elementsOnMat[i], "card"))
		{
			//Check that it's not a token
			if (elementsOnMat[i].getAttribute("token") != 'true')
			{
				//Check that it's not a commander
				if (elementsOnMat[i].getAttribute("commander") != 'true')
				{
					numCardsInDeck = numCardsInDeck + 1;
				}
				//Check if it's a land
				if (elementsOnMat[i].getAttribute("land") == 'true')
				{
					//Get the mana production bitvector from it
					var manaProductionBitVector = parseInt(elementsOnMat[i].getAttribute('mana_production_bitvector'));
					if (manaProductionBitVector != 0)
					{
						//Filter the manaProductionBitVector by the colors mentioned in the cost.
						var filteredManaProductionBitVector = manaProductionBitVector & cost.colorBitVector;
						//If generic mana is part of the cost, each land can be used to produce generic mana
						if (cost.generic > 0)
						{
							filteredManaProductionBitVector = filteredManaProductionBitVector | 0x40;
						}
						//Check if this land helps us pay the cost
						if (filteredManaProductionBitVector != 0)
						{
							++numUsefulLandsInDeck;
							//Check to see if we've recorded this cost
							var found = false;
							for ( j = 0; j < manaProduction.length; ++j)
							{
								//If this previously added production matches,
								if (manaProduction[j].manaProductionBitVector == filteredManaProductionBitVector)
								{
									//Increment the count of lands that have this kind of production
									++manaProduction[j].count;
									found = true;
									break;
								}
							}
							//If we haven't found it, add it
							if (!found)
							{
								manaProduction.push(new LandCount(filteredManaProductionBitVector));
							}
						}
					}
				}
			}
		}
	}

	//Assume we've already drawn the card from the deck
	if (!isCommander)
	{
		numCardsInDeck = numCardsInDeck - 1;
	}

	//Precompute binomial coefficients
	computePascalsTriangleUpTo(numCardsInDeck);

	//console.log("Cards in Deck: " + numCardsInDeck);
	//var manaProductionToString = "Lands: "
	//for (j = 0; j < manaProduction.length; ++j)
	//{
	//	manaProductionToString = manaProductionToString + manaProduction[j].count +  ":" + manaProduction[j].manaProductionBitVector + " ";
	//}
	//console.log(manaProductionToString);

	//Generate all combinations of up to maxNumLands lands that can't cast it
	var combinationsThatCantCast = [];
	var missingColorRequirement = false;
	if (cost.total > 0 && cost.total < maxNumLands)
	{
		//Consider combinations that just don't have enough lands
		var numSubCombinations = 1;
		//Only need to consider combinations that don't exceed the number of each kind of land in our deck
		var maxOfEachProductionToConsider = [];
		for (i = 0; i < manaProduction.length; ++i)
		{
			var maxOfThisProductionToConsider = manaProduction[i].count + 1;	//Need to add one because the modulo operation won't reach a combination with .count otherwise
			if (maxOfThisProductionToConsider > cost.total)
			{
				maxOfThisProductionToConsider = cost.total;
			}
			maxOfEachProductionToConsider.push(maxOfThisProductionToConsider);
			numSubCombinations = numSubCombinations * maxOfThisProductionToConsider;
		}
		//TODO: This considers 6+ times as many combinations as it actually needs to. Can this be optimized?
		for ( i = 0; i < numSubCombinations; ++i)
		{
			var combo = [];
			var quotient = i;
			var sumAmountOfManaProduction = 0;
			//Generate the number of lands of each kind that this combination represents
			for (j = 0; j < manaProduction.length; ++j )
			{
				var amountOfThisManaProduction = quotient % maxOfEachProductionToConsider[j];
				quotient = (quotient - amountOfThisManaProduction) / maxOfEachProductionToConsider[j];
				sumAmountOfManaProduction = sumAmountOfManaProduction + amountOfThisManaProduction;
				combo.push(amountOfThisManaProduction);
			}
			
			//If this isn't enough lands
			if (sumAmountOfManaProduction < cost.total) {
				//Save this combination as one that can't pay the cost
				combinationsThatCantCast.push(combo);
			}
		}

		function generateLandCombinations(numColorSymbols, colorBitVector)
		{
			//Consider combinations that don't satisfy color requirements
			//First, check if there's any of this symbol. Also check if doing this isn't pointless
			if (numColorSymbols > 0 && !missingColorRequirement) {
				//console.log("Processing Color: " + colorBitVector);
				//console.log("Num Symbols: " + numColorSymbols);
				//Split the lands into ones that can pay these symbols, and ones that cannot
				var colorProducers = [];
				var others = [];
				for (i = 0; i < manaProduction.length; ++i)
				{
					if (manaProduction[i].manaProductionBitVector & colorBitVector)	//Check if this land type produces a satisfactory color
					{
						colorProducers.push(i);
					} else {
						others.push(i);
					}
				}
				//for (i = 0; i < colorProducers.length; ++i)
				//{
				//	console.log("Color Producing Land: " + manaProduction[colorProducers[i]].manaProductionBitVector);
				//}
				//for (i = 0; i < others.length; ++i)
				//{
				//	console.log("Other Land: " + manaProduction[others[i]].manaProductionBitVector);
				//}
				if (colorProducers.length == 0)
				{
					missingColorRequirement = true;
					return;
				}
				//If there are fewer than cost.w white producing lands, you can't cast it.
				//Generate all combinations of cost.w - 1 white-producing lands
				var numSubCombinations = 1;
				var maxOfEachProductionToConsider = [];
				for (i = 0; i < colorProducers.length; ++i)
				{
					var maxOfThisProductionToConsider = manaProduction[colorProducers[i]].count + 1;
					if (maxOfThisProductionToConsider > numColorSymbols)
					{
						maxOfThisProductionToConsider = numColorSymbols;
					}
					maxOfEachProductionToConsider.push(maxOfThisProductionToConsider);
					numSubCombinations = numSubCombinations * maxOfThisProductionToConsider;
				}
				for (i = 0; i < numSubCombinations; ++i)
				{
					var subCombo = [];
					var quotient = i;
					var sumAmountOfManaProduction = 0;
					for (j = 0; j < colorProducers.length; ++j)
					{
						var amountOfThisManaProduction = quotient % maxOfEachProductionToConsider[j];
						quotient = (quotient - amountOfThisManaProduction) / maxOfEachProductionToConsider[j];
						sumAmountOfManaProduction = sumAmountOfManaProduction + amountOfThisManaProduction;
						subCombo.push(amountOfThisManaProduction);
					}

					//var comboToString = "Insufficient color producer combo: "
					//for (j = 0; j < subCombo.length; ++j)
					//{
					//	comboToString = comboToString + subCombo[j] +  ":" + manaProduction[colorProducers[j]].manaProductionBitVector + " ";
					//}
					//console.log(comboToString);

					//If this isn't enough lands of the color we need
					if (sumAmountOfManaProduction < numColorSymbols)
					{
						//Generate all combinations of the other land types
						var numSubCombinations2 = 1;
						var maxOfEachProductionToConsider2 = [];
						for (j = 0; j < others.length; ++j)
						{
							var maxOfThisProductionToConsider2 = manaProduction[others[j]].count + 1;
							if (maxOfThisProductionToConsider2 > maxNumLands)
							{
								maxOfThisProductionToConsider2 = maxNumLands;
							}
							maxOfEachProductionToConsider2.push(maxOfThisProductionToConsider2);
							numSubCombinations2 = numSubCombinations2 * maxOfThisProductionToConsider2;
						}
						for (j = 0; j < numSubCombinations2; ++j)
						{
							var subCombo2 = [];
							quotient = j;
							var sumAmountOfManaProduction2 = sumAmountOfManaProduction;
							for (k = 0; k < others.length; ++k)
							{
								var amountOfThisManaProduction = quotient % maxOfEachProductionToConsider2[k];
								quotient = (quotient - amountOfThisManaProduction) / maxOfEachProductionToConsider2[k];
								sumAmountOfManaProduction2 = sumAmountOfManaProduction2 + amountOfThisManaProduction;
								subCombo2.push(amountOfThisManaProduction);
							}
							//Check that we didn't already cover this combo with the generic case
							if ( sumAmountOfManaProduction2 >= cost.total)
							{
								//Generate the complete combo
								var combo = [];
								for (k = 0; k < colorProducers.length; ++k)
								{
									combo[colorProducers[k]] = subCombo[k];
								}
								for (k = 0; k < others.length; ++k)
								{
									combo[others[k]] = subCombo2[k];
								}
								//Add the combo
								combinationsThatCantCast.push(combo);
							}
						}
					}
				}
			}
		} //End function

		//Generate the combinations of that can't cast each mana requirement
		generateLandCombinations(cost.w, 0x01);
		generateLandCombinations(cost.u, 0x02);
		generateLandCombinations(cost.b, 0x04);
		generateLandCombinations(cost.r, 0x08);
		generateLandCombinations(cost.g, 0x10);
		generateLandCombinations(cost.c, 0x20);
		//Generate the combinations of lands that can't cast each hybrid mana requirement
		//WARNING: This assumes that you have no other costs of the hybrid mana's colors.
		generateLandCombinations(cost.wu, 0x01 | 0x02);
		generateLandCombinations(cost.ub, 0x02 | 0x04);
		generateLandCombinations(cost.br, 0x04 | 0x08);
		generateLandCombinations(cost.rg, 0x08 | 0x10);
		generateLandCombinations(cost.gw, 0x10 | 0x01);
		generateLandCombinations(cost.wb, 0x01 | 0x04);
		generateLandCombinations(cost.ur, 0x02 | 0x08);
		generateLandCombinations(cost.bg, 0x04 | 0x10);
		generateLandCombinations(cost.rw, 0x08 | 0x01);
		generateLandCombinations(cost.gu, 0x10 | 0x02);
	}

	//Sort the combos by the number of lands
	combinationsThatCantCast.sort(
		function(a,b){
			//Compute the number of lands in each combo
			var aSum = 0;
			var bSum = 0;
			var i = 0;
			var equal = true;
			var aHigher = false;
			for (i = 0; i < a.length; ++i)
			{
				if (equal && a[i] != b[i])
				{
					equal = false;
					if (a[i] > b[i])
					{
						aHigher = true;
					}
				}
				aSum = aSum + a[i];
				bSum = bSum + b[i];
			}

			if (aSum == bSum)
			{
				//Tiebreaker. Ensures duplicate combinations are adjacent for easier detection
				if (aHigher)
				{
					return -1;
				} else {
					return 1;
				}
			} else {
				return aSum - bSum;
			}
		}
	);

	//console.log("Num Combinations: " + combinationsThatCantCast.length);

	/*for (i = 0; i < combinationsThatCantCast.length; ++i)
	{
		var comboToString = ""
		for (j = 0; j < combinationsThatCantCast[i].length; ++j)
		{
			comboToString = comboToString + combinationsThatCantCast[i][j] +  ":" + manaProduction[j].manaProductionBitVector + " ";
		}
		console.log(comboToString);
	}*/

	//Plot the probabilities
	var castingProbabilities = [];
	var cardsDrawnFromDeck = 0;
	//For each sample size
	for (cardsDrawnFromDeck = 0; cardsDrawnFromDeck < maxNumLands; ++cardsDrawnFromDeck)
	{
		if (isCommander)
		{
			sampleSize = cardsDrawnFromDeck;
		} else {
			sampleSize = cardsDrawnFromDeck - 1;
		}
		//Is the samplesize even big enough for the mana cost? Also check if we aren't missing a mana color
		if (sampleSize < cost.total || missingColorRequirement)
		{
			castingProbabilities.push(0);
		} else {
			//For each combination
			var c = 0;
			var sum = 0;
			for (c = 0; c < combinationsThatCantCast.length; ++c) {
				var duplicate = true;
				var numLandsInCombination = 0;
				if (c != 0)
				{
					//Compare this combination to the previous to check for duplicates
					for (i = 0; i < combinationsThatCantCast[c].length; ++i)
					{
						if (combinationsThatCantCast[c - 1][i] != combinationsThatCantCast[c][i])
						{
							duplicate = false;
						}
						numLandsInCombination = numLandsInCombination + combinationsThatCantCast[c][i];
					}
				} else {
					duplicate = false;
					for (i = 0; i < combinationsThatCantCast[c].length; ++i)
					{
						numLandsInCombination = numLandsInCombination + combinationsThatCantCast[c][i];
					}
				}
				//If the lands in the combination outnumber the sample size
				if (numLandsInCombination > sampleSize)
				{
					//Don't need to consider any more combinations
					break;
				}
				//Check that this combination isn't a duplicate of the previous
				if (!duplicate)
				{
					//Compute the term this combination contributes to the sum
					//First compute the term that represents the dead cards
					var product = nChooseK(numCardsInDeck - numUsefulLandsInDeck, sampleSize - numLandsInCombination);
					for (i = 0; i < combinationsThatCantCast[c].length; ++i)
					{
						product = product * nChooseK(manaProduction[i].count, combinationsThatCantCast[c][i]);
					}
					sum = sum + product;
				}
			}
			//Divide by the denominator
			var probabilityCantCast = sum / nChooseK(numCardsInDeck, sampleSize);
			castingProbabilities.push(1 - probabilityCantCast);
		}
	}

	//for (i = 0; i < castingProbabilities.length; ++i)
	//{
	//	console.log("After drawing " + i + " cards: " + castingProbabilities[i] * 100 + "%");
	//}

	return castingProbabilities;
}

function computeCurveCastingProbabilityOfCard(cardElement)
{
	//console.log("Name: " +cardElement.getAttribute('name'));
	//Get the cost of the currently selected card
	var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
	//console.log("Total Cost: " + cost.total);
	//Get whether this card is a commander
	var isCommander = cardElement.getAttribute('commander') == 'true';
	//console.log("Is Commander: " + cardElement.getAttribute('commander'));
	//Count how many non-commander non-token cards are on the playmat.
	var numCardsInDeck = 0;
	var numUsefulLandsInDeck = 0;
	//Also count the mana production available
	var manaProduction = [];

	//Get all the elements on the playmat
	var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

	//Figure out which of the elements are cards
	var i = 0;
	var j = 0;
	var k = 0;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		//Check that the element is a card
		if (hasClass(elementsOnMat[i], "card"))
		{
			//Check that it's not a token
			if (elementsOnMat[i].getAttribute("token") != 'true')
			{
				//Check that it's not a commander
				if (elementsOnMat[i].getAttribute("commander") != 'true')
				{
					numCardsInDeck = numCardsInDeck + 1;
				}
				//Check if it's a land
				if (elementsOnMat[i].getAttribute("land") == 'true')
				{
					//Get the mana production bitvector from it
					var manaProductionBitVector = parseInt(elementsOnMat[i].getAttribute('mana_production_bitvector'));
					if (manaProductionBitVector != 0)
					{
						//Filter the manaProductionBitVector by the colors mentioned in the cost.
						var filteredManaProductionBitVector = manaProductionBitVector & cost.colorBitVector;
						//If generic mana is part of the cost, each land can be used to produce generic mana
						if (cost.generic > 0)
						{
							filteredManaProductionBitVector = filteredManaProductionBitVector | 0x40;
						}
						//Check if this land helps us pay the cost
						if (filteredManaProductionBitVector != 0)
						{
							++numUsefulLandsInDeck;
							//Check to see if we've recorded this cost
							var found = false;
							for ( j = 0; j < manaProduction.length; ++j)
							{
								//If this previously added production matches,
								if (manaProduction[j].manaProductionBitVector == filteredManaProductionBitVector)
								{
									//Increment the count of lands that have this kind of production
									++manaProduction[j].count;
									found = true;
									break;
								}
							}
							//If we haven't found it, add it
							if (!found)
							{
								manaProduction.push(new LandCount(filteredManaProductionBitVector));
							}
						}
					}
				}
			}
		}
	}

	//Assume we've already drawn the card from the deck
	if (!isCommander)
	{
		numCardsInDeck = numCardsInDeck - 1;
	}

	//Precompute binomial coefficients
	computePascalsTriangleUpTo(numCardsInDeck);

	//console.log("Cards in Deck: " + numCardsInDeck);
	//var manaProductionToString = "Lands: "
	//for (j = 0; j < manaProduction.length; ++j)
	//{
	//	manaProductionToString = manaProductionToString + manaProduction[j].count +  ":" + manaProduction[j].manaProductionBitVector + " ";
	//}
	//console.log(manaProductionToString);

	//Figure out how many cards we'll have drawn from our deck if we're tryin to play it on curve on the play
	var cardsDrawnFromDeck = 6 + cost.total;
	if (cardsDrawnFromDeck < 7)
	{
		cardsDrawnFromDeck = 7;
	}

	//Generate all combinations of up to cardsDrawnFromDeck lands that can't cast it
	var combinationsThatCantCast = [];
	var missingColorRequirement = false;
	if (cost.total > 0 && cost.total < cardsDrawnFromDeck)
	{
		//Consider combinations that just don't have enough lands
		var numSubCombinations = 1;
		//Only need to consider combinations that don't exceed the number of each kind of land in our deck
		var maxOfEachProductionToConsider = [];
		for (i = 0; i < manaProduction.length; ++i)
		{
			var maxOfThisProductionToConsider = manaProduction[i].count + 1;	//Need to add one because the modulo operation won't reach a combination with .count otherwise
			if (maxOfThisProductionToConsider > cost.total)
			{
				maxOfThisProductionToConsider = cost.total;
			}
			maxOfEachProductionToConsider.push(maxOfThisProductionToConsider);
			numSubCombinations = numSubCombinations * maxOfThisProductionToConsider;
		}
		for ( i = 0; i < numSubCombinations; ++i)
		{
			var combo = [];
			var quotient = i;
			var sumAmountOfManaProduction = 0;
			//Generate the number of lands of each kind that this combination represents
			for (j = 0; j < manaProduction.length; ++j )
			{
				var amountOfThisManaProduction = quotient % maxOfEachProductionToConsider[j];
				quotient = (quotient - amountOfThisManaProduction) / maxOfEachProductionToConsider[j];
				sumAmountOfManaProduction = sumAmountOfManaProduction + amountOfThisManaProduction;
				combo.push(amountOfThisManaProduction);
			}
			
			//If this isn't enough lands
			if (sumAmountOfManaProduction < cost.total) {
				//Save this combination as one that can't pay the cost
				combinationsThatCantCast.push(combo);
			}
		}

		function generateLandCombinations(numColorSymbols, colorBitVector)
		{
			//Consider combinations that don't satisfy color requirements
			//First, check if there's any of this symbol. Also check if doing this isn't pointless
			if (numColorSymbols > 0 && !missingColorRequirement) {
				//console.log("Processing Color: " + colorBitVector);
				//console.log("Num Symbols: " + numColorSymbols);
				//Split the lands into ones that can pay these symbols, and ones that cannot
				var colorProducers = [];
				var others = [];
				for (i = 0; i < manaProduction.length; ++i)
				{
					if (manaProduction[i].manaProductionBitVector & colorBitVector)	//Check if this land type produces a satisfactory color
					{
						colorProducers.push(i);
					} else {
						others.push(i);
					}
				}
				//for (i = 0; i < colorProducers.length; ++i)
				//{
				//	console.log("Color Producing Land: " + manaProduction[colorProducers[i]].manaProductionBitVector);
				//}
				//for (i = 0; i < others.length; ++i)
				//{
				//	console.log("Other Land: " + manaProduction[others[i]].manaProductionBitVector);
				//}
				if (colorProducers.length == 0)
				{
					missingColorRequirement = true;
					return;
				}
				//If there are fewer than cost.w white producing lands, you can't cast it.
				//Generate all combinations of cost.w - 1 white-producing lands
				var numSubCombinations = 1;
				var maxOfEachProductionToConsider = [];
				for (i = 0; i < colorProducers.length; ++i)
				{
					var maxOfThisProductionToConsider = manaProduction[colorProducers[i]].count + 1;
					if (maxOfThisProductionToConsider > numColorSymbols)
					{
						maxOfThisProductionToConsider = numColorSymbols;
					}
					maxOfEachProductionToConsider.push(maxOfThisProductionToConsider);
					numSubCombinations = numSubCombinations * maxOfThisProductionToConsider;
				}
				for (i = 0; i < numSubCombinations; ++i)
				{
					var subCombo = [];
					var quotient = i;
					var sumAmountOfManaProduction = 0;
					for (j = 0; j < colorProducers.length; ++j)
					{
						var amountOfThisManaProduction = quotient % maxOfEachProductionToConsider[j];
						quotient = (quotient - amountOfThisManaProduction) / maxOfEachProductionToConsider[j];
						sumAmountOfManaProduction = sumAmountOfManaProduction + amountOfThisManaProduction;
						subCombo.push(amountOfThisManaProduction);
					}

					//var comboToString = "Insufficient color producer combo: "
					//for (j = 0; j < subCombo.length; ++j)
					//{
					//	comboToString = comboToString + subCombo[j] +  ":" + manaProduction[colorProducers[j]].manaProductionBitVector + " ";
					//}
					//console.log(comboToString);

					//If this isn't enough lands of the color we need
					if (sumAmountOfManaProduction < numColorSymbols)
					{
						//Generate all combinations of the other land types
						var numSubCombinations2 = 1;
						var maxOfEachProductionToConsider2 = [];
						for (j = 0; j < others.length; ++j)
						{
							var maxOfThisProductionToConsider2 = manaProduction[others[j]].count + 1;
							if (maxOfThisProductionToConsider2 > cardsDrawnFromDeck)
							{
								maxOfThisProductionToConsider2 = cardsDrawnFromDeck;
							}
							maxOfEachProductionToConsider2.push(maxOfThisProductionToConsider2);
							numSubCombinations2 = numSubCombinations2 * maxOfThisProductionToConsider2;
						}
						for (j = 0; j < numSubCombinations2; ++j)
						{
							var subCombo2 = [];
							quotient = j;
							var sumAmountOfManaProduction2 = sumAmountOfManaProduction;
							for (k = 0; k < others.length; ++k)
							{
								var amountOfThisManaProduction = quotient % maxOfEachProductionToConsider2[k];
								quotient = (quotient - amountOfThisManaProduction) / maxOfEachProductionToConsider2[k];
								sumAmountOfManaProduction2 = sumAmountOfManaProduction2 + amountOfThisManaProduction;
								subCombo2.push(amountOfThisManaProduction);
							}
							//Check that we didn't already cover this combo with the generic case
							if ( sumAmountOfManaProduction2 >= cost.total)
							{
								//Generate the complete combo
								var combo = [];
								for (k = 0; k < colorProducers.length; ++k)
								{
									combo[colorProducers[k]] = subCombo[k];
								}
								for (k = 0; k < others.length; ++k)
								{
									combo[others[k]] = subCombo2[k];
								}
								//Add the combo
								combinationsThatCantCast.push(combo);
							}
						}
					}
				}
			}
		} //End function

		//Generate the combinations of that can't cast each mana requirement
		generateLandCombinations(cost.w, 0x01);
		generateLandCombinations(cost.u, 0x02);
		generateLandCombinations(cost.b, 0x04);
		generateLandCombinations(cost.r, 0x08);
		generateLandCombinations(cost.g, 0x10);
		generateLandCombinations(cost.c, 0x20);
		//Generate the combinations of lands that can't cast each hybrid mana requirement
		//WARNING: This assumes that you have no other costs of the hybrid mana's colors.
		generateLandCombinations(cost.wu, 0x01 | 0x02);
		generateLandCombinations(cost.ub, 0x02 | 0x04);
		generateLandCombinations(cost.br, 0x04 | 0x08);
		generateLandCombinations(cost.rg, 0x08 | 0x10);
		generateLandCombinations(cost.gw, 0x10 | 0x01);
		generateLandCombinations(cost.wb, 0x01 | 0x04);
		generateLandCombinations(cost.ur, 0x02 | 0x08);
		generateLandCombinations(cost.bg, 0x04 | 0x10);
		generateLandCombinations(cost.rw, 0x08 | 0x01);
		generateLandCombinations(cost.gu, 0x10 | 0x02);
	}

	//Sort the combos by the number of lands
	combinationsThatCantCast.sort(
		function(a,b){
			//Compute the number of lands in each combo
			var aSum = 0;
			var bSum = 0;
			var i = 0;
			var equal = true;
			var aHigher = false;
			for (i = 0; i < a.length; ++i)
			{
				if (equal && a[i] != b[i])
				{
					equal = false;
					if (a[i] > b[i])
					{
						aHigher = true;
					}
				}
				aSum = aSum + a[i];
				bSum = bSum + b[i];
			}

			if (aSum == bSum)
			{
				//Tiebreaker. Ensures duplicate combinations are adjacent for easier detection
				if (aHigher)
				{
					return -1;
				} else {
					return 1;
				}
			} else {
				return aSum - bSum;
			}
		}
	);

	//console.log("Num Combinations: " + combinationsThatCantCast.length);

	/*for (i = 0; i < combinationsThatCantCast.length; ++i)
	{
		var comboToString = ""
		for (j = 0; j < combinationsThatCantCast[i].length; ++j)
		{
			comboToString = comboToString + combinationsThatCantCast[i][j] +  ":" + manaProduction[j].manaProductionBitVector + " ";
		}
		console.log(comboToString);
	}*/

	//Plot the probabilities

	if (isCommander)
	{
		sampleSize = cardsDrawnFromDeck;
	} else {
		sampleSize = cardsDrawnFromDeck - 1;
	}
	//Is the samplesize even big enough for the mana cost? Also check if we aren't missing a mana color
	if (sampleSize < cost.total || missingColorRequirement)
	{
		return 0;
	} else {
		//For each combination
		var c = 0;
		var sum = 0;
		for (c = 0; c < combinationsThatCantCast.length; ++c) {
			var duplicate = true;
			var numLandsInCombination = 0;
			if (c != 0)
			{
				//Compare this combination to the previous to check for duplicates
				for (i = 0; i < combinationsThatCantCast[c].length; ++i)
				{
					if (combinationsThatCantCast[c - 1][i] != combinationsThatCantCast[c][i])
					{
						duplicate = false;
					}
					numLandsInCombination = numLandsInCombination + combinationsThatCantCast[c][i];
				}
			} else {
				duplicate = false;
				for (i = 0; i < combinationsThatCantCast[c].length; ++i)
				{
					numLandsInCombination = numLandsInCombination + combinationsThatCantCast[c][i];
				}
			}
			//If the lands in the combination outnumber the sample size
			if (numLandsInCombination > sampleSize)
			{
				//Don't need to consider any more combinations
				break;
			}
			//Check that this combination isn't a duplicate of the previous
			if (!duplicate)
			{
				//Compute the term this combination contributes to the sum
				//First compute the term that represents the dead cards
				var product = nChooseK(numCardsInDeck - numUsefulLandsInDeck, sampleSize - numLandsInCombination);
				for (i = 0; i < combinationsThatCantCast[c].length; ++i)
				{
					product = product * nChooseK(manaProduction[i].count, combinationsThatCantCast[c][i]);
				}
				sum = sum + product;
			}
		}
		//Divide by the denominator
		var probabilityCantCast = sum / nChooseK(numCardsInDeck, sampleSize);
		return 1 - probabilityCantCast;
	}
}

function analyzeCard(){
	//Save the changes
	saveEditCardSettings();
	var castingProbabilities = computeCastingProbabilitiesOfCard(selectedCard);
	//Get the mana cost again
	var cost = new ManaCost(selectedCard.getAttribute('casting_cost'));
	//Figure out the first turn you can cast this on
	var cardsDrawnByTheTurnYouCanCastIt = 6 + cost.total;
	if (cardsDrawnByTheTurnYouCanCastIt < 7)
	{
		cardsDrawnByTheTurnYouCanCastIt = 7;
	}

	//For each number of cards drawn from deck
	var i = 0;
	for (i = 0; i < castingProbabilities.length; ++i)
	{
		//Set this bar's height
		var barElement = document.getElementById('graph ' + i + ' bar');
		var barLabelElement = document.getElementById('graph ' + i + ' bar label');
		barElement.style.height = (200 * castingProbabilities[i]) + 'px';
		barLabelElement.innerHTML = '&nbsp' + (Math.round(10000*castingProbabilities[i])/100) + '&nbsp';
		if (castingProbabilities[i] < 0.5) {
			barElement.style.background = 'red';
			barLabelElement.className = 'graph_bar_label_outside';
		} else if (castingProbabilities[i] < 0.6) {
			barElement.style.background = 'orange';
			barLabelElement.className = 'graph_bar_label_inside';
		} else if (castingProbabilities[i] < 0.7) {
			barElement.style.background = 'yellow';
			barLabelElement.className = 'graph_bar_label_inside';
		} else if (castingProbabilities[i] < 0.8) {
			barElement.style.background = 'green';
			barLabelElement.className = 'graph_bar_label_inside';
		} else if (castingProbabilities[i] < 0.9) {
			barElement.style.background = 'rgb(0, 46, 255)';
			barLabelElement.className = 'graph_bar_label_inside';
		} else {
			barElement.style.background = 'purple';
			barLabelElement.className = 'graph_bar_label_inside';
		}
		if (i == cardsDrawnByTheTurnYouCanCastIt)
		{
			barElement.className = 'highlighted_graph_bar';
		} else {
			barElement.className = 'graph_bar';
		}
	}

	//Make the graph visible
	showElement(document.getElementById('analyze card results'));
}

//Main
window.onload = function() {
	//Create some cards for testing
	document.onmousemove=dragElement;
	document.onmouseup=stopDrag;
	document.getElementById("card info popup").addEventListener("mouseleave", hideCardInfoMenu);
	document.getElementById("magnified card view").addEventListener("mousedown", hideCardInfoMenu);
	document.getElementById("playmat").addEventListener("mousedown", startSelection);
	/*document.getElementById("land checkbox").onclick = permanentTypeSelected;
	document.getElementById("creature checkbox").onclick = permanentTypeSelected;
	document.getElementById("planeswalker checkbox").onclick = permanentTypeSelected;
	document.getElementById("artifact checkbox").onclick = permanentTypeSelected;
	document.getElementById("enchantment checkbox").onclick = permanentTypeSelected;
	document.getElementById("sorcery checkbox").onclick = sorceryTypeSelected;
	document.getElementById("instant checkbox").onclick = instantTypeSelected;*/
	document.getElementById("card type").onchange = updateEditCardFormByType;
	document.getElementById("deck name").addEventListener("mouseout", updateDocumentTitleWithDeckName);

	var sideboard = document.getElementById("sideboard");
	sideboard.addEventListener("mouseover", mouseEnterSideboard);
	sideboard.addEventListener("mouseout", mouseLeaveSideboard);

	//Go through all the elements on the playmat and set up their javascript functions
	var elementsOnMat = document.getElementById("playmat").getElementsByTagName('*');
	var i, element;
	for (i = 0; i < elementsOnMat.length; ++i)
	{
		element = elementsOnMat[i];
		//Set up cards
		if (hasClass(element,'card')){
			element.addEventListener("mousedown", mouseDownCard);
			element.addEventListener("mouseup", mouseUpCard);
			element.addEventListener("mouseenter", mouseEnterCard);
			element.addEventListener("mouseleave", mouseLeaveCard);
		}
	}

	//Go through all the elements in the sideboard and set up their javascript functions
	var elementsInSideboard = document.getElementById("sideboard").getElementsByTagName('*');
	for (i = 0; i < elementsInSideboard.length; ++i)
	{
		element = elementsInSideboard[i];
		//Set up cards
		if (hasClass(element,'card')){
			element.addEventListener("mousedown", mouseDownCard);
			element.addEventListener("mouseup", mouseUpCard);
			element.addEventListener("mouseenter", mouseEnterCard);
			element.addEventListener("mouseleave", mouseLeaveCard);
		}
	}

	deselectAll();

	//Resize document to fit
	resizeDocument();
}

window.onbeforeunload = function() {
	return true;
};
		
	</script>
</body>
</html>