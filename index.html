<!DOCTYPE html>
<html lang="en-US">
<head>
	<title>MTG Deck Prototyper</title>
	<style>
		body {
			margin: 0px;
			background-color:rgb(32,32,32);
			min-width: 100%;
			min-height: 100%;
			height:100%;
			width:100%;
			margin:0px;
			padding:0px;
		}

		html {
			height:100%;
			width:100%;
			min-height: 100%;
			min-width: 100%;
			margin:0px;
			padding:0px;
		}

		.rotated {
			-webkit-transform: rotate(90deg);
			-moz-transform: rotate(90deg);
			-o-transform: rotate(90deg);
			-ms-transform: rotate(90deg);
			transform: rotate(90deg);
		}

		.selected {
			border-style: dotted;
			border-color: white;
			border-width: 1px;
		}

		.sideboard {
			position: fixed;
			border: 1px solid rgb(0,0,0);
			width: 250px;
			right: 25px;
			top: 25px;
			bottom: 25px;
			background-color: rgba(255,255,255,0.4);
			box-shadow: 2px 2px 4px rgba(0,0,0,0.4)
			-moz-border-radius: 5px;
			-webkit-border-radius: 5px;
			visibility: hidden;
			overflow-y: scroll;
			overflow-x: hidden;
		}

		.sideboarded {
		}

		.green_selector {
			position: absolute;
			border-color: white;
			border-width: 1px;
			border-style: dashed;
			background: rgba(0,255,0,0.2);
		}

		.blue_selector {
			position: absolute;
			border-color: white;
			border-width: 1px;
			border-style: solid;
			background: rgba(0,0,255,0.2);
		}

		.invisible_selector {
			position: absolute;
			border-color: white;
			border-width: 0px;
			border-style: solid;
			background: transparent;
		}

		.preferences_menu {
			position: fixed; /* keep menu always in middle of screen even when scrolled, change to absolute if you dont want that */
			left: 25px;
			right: 300px;
			top: 25px;
			bottom: 25px;
			display: none;
			background-color: rgba(255,255,255,0.4);
			border: 1px solid black;
			box-shadow: 2px 2px 4px rgba(0,0,0,0.4)
		}
		
		.preferences_menu .close_btn {
			position: absolute;
			top:0;
			right:0;
		}

		.playmat {
			height:100%;
			width:100%;
		}

		.left {
			left:0px;
		}

		.secondleft {
			left:104px;
		}

		.right {
			right:0px;
		}

		.main_control_panel {
			position: absolute;
			height: 30px;
		}

		.card_info_popup {
			position: absolute;
			background-color: black;
			height: 495px;
			width: 312px;
			top: 0px;
			left: 0px;
			border: 5px solid rgb(0,0,0);
			-moz-border-radius: 5px;
			-webkit-border-radius: 5px;
			visibility: hidden;
		}
		.magnfied_card_view{
			width: 312px;
			height: 445px;
			border-spacing: 0px;
		}
		.card_popup_control_panel {
			width:312px;
			height: 50px;
		}
		.card_popup_control_panel_button {
			width: 104px;
			height: 50px;
			top: 445px;
			position:absolute;
		}
		.edit_card_control_panel {
			width:180px;
			height: 495px;
			margin: 0px;
			top: -5px;
			left: 312px;
			border: 5px solid rgb(0,0,0);
			-moz-border-radius: 5px;
			-webkit-border-radius: 5px;
			position: absolute;
			background-color:rgb(127,127,127);
			visibility: hidden;
		}

		.card{
			width: 212px;
			height: 296px;
		}

		.draggable{
			position:absolute;
			cursor: move;
		}
		
		#counter_container {
			position:absolute;
			left:0;
			top:0;
		}
		
		#counter_template {
			display: none;
		}
		
		.counter {
			position: absolute;
			width: 60px;
			height: 60px;
			border-radius: 60px;
			box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
		}
		
		.counter .value {
			border: none;
			background: none;
			text-align: center;
			position: absolute;
			left:0;
			right:0;
			padding:22px;
		}
		
		.counter .btn {
			position: absolute;
			width: 22px;
			right: 0;
		}
		
		.counter .increment {
			top: 0;
		}
		
		.counter .decrement {
			bottom: 0;
		}
	</style>
</head>
<body id="body">
	
	<div id="main control panel" class="main_control_panel">
		<input type="text" id="cardimageurl" value="Enter card image URL here" onclick="clearCardImageUrlEntry()"/>
		<button id="add card button" onclick="addCard()">Add Card(s)</button>
		<button id="stack button" onclick="stack()">Stack</button>
		<button id="cost sort button" onclick="costSort()">Sort by Cost</button>
		<button id="color sort button" onclick="colorSort()">Sort by Color</button>
		<button id="type sort button" onclick="typeSort()">Sort by Type</button>
		<button id="purpose sort button" onclick="purposeSort()">Sort by Purpose</button>
		<button id="new game button" onclick="newGame()">New Game</button>
		<button id="shuffle button" onclick="shuffle()">Shuffle</button>
		<button id="sideboard button" onclick="toggleSideboard()">Sideboard</button>
		<button id="add counter button" onclick="addCounter()">Add Counter</button>
		<button id="preferences button" onclick="togglePreferences()">Preferences</button>
		<button id="help button" onclick="toggleHelp()">Help</button>
		<button id="delete selection button" onclick="deleteSelection()">Delete</button>
	</div>
	<div id="playmat" class="playmat">
	</div>

	<div id="selector" class="invisible_selector">
	</div>

	<div id="sideboard" class="sideboard">
	</div>

	<div id="preferences menu" class="preferences_menu">
		<button class="close_btn" onclick="togglePreferences()">X</button>
		&nbspStarting Life Total:<br>
		&nbsp<input type="number" id="starting life" value="20"/><br>
		&nbspCard Sleeve Image URL:<br>
		&nbsp<input type="text" id="card sleeve image" value="http://i.ebayimg.com/images/g/l9YAAOSweW5VX2or/s-l300.jpg"/><br>
		&nbspPlaymat Image URL:<br>
		&nbsp<input type="text" id="playmat image" value=""/><br>
	</div>

	<div id="card info popup" class="card_info_popup">
		<img id="magnified card view" class="magnfied_card_view" src=""/>
		<div id="card info control panel" class="card_popup_control_panel">
			<button class="bottom left card_popup_control_panel_button" onclick="copyCard()">Copy</button>
			<button class="bottom secondleft card_popup_control_panel_button" onclick="toggleEditCard()">Edit</button>
			<button class="bottom right card_popup_control_panel_button" onclick="deleteCard()">Delete</button>
		</div>
		<div id="edit card control panel" class="edit_card_control_panel">
			&nbspCard Name:<br>
			&nbsp<input type="text" id="card name input" value=""/><br>
			&nbspPurpose:<br>
			&nbsp<input type="text" id="purpose input" value=""/><br>
			&nbspType:<br>
			&nbsp<label><input type="checkbox" id="land checkbox" />Land</label><br>
			&nbsp<label><input type="checkbox" id="creature checkbox" />Creature</label><br>
			&nbsp<label><input type="checkbox" id="planeswalker checkbox" />Planeswalker</label><br>
			&nbsp<label><input type="checkbox" id="artifact checkbox" />Artifact</label><br>
			&nbsp<label><input type="checkbox" id="enchantment checkbox" />Enchantment</label><br>
			&nbsp<label><input type="checkbox" id="sorcery checkbox" />Sorcery</label><br>
			&nbsp<label><input type="checkbox" id="instant checkbox" />Instant</label><br>
			<div id="land menu">
				&nbspMana Production:<br>
				&nbsp<label><input type="checkbox" id="produces white checkbox" />W</label>
				<label><input type="checkbox" id="produces blue checkbox" />U</label>
				<label><input type="checkbox" id="produces black checkbox" />B</label><br>
				&nbsp<label><input type="checkbox" id="produces red checkbox" />R</label>
				<label><input type="checkbox" id="produces green checkbox" />G</label>
				<label><input type="checkbox" id="produces colorless checkbox" />C</label><br>
			</div>
			<div id="nonland menu">
				&nbspCasting Cost:<br>
				&nbsp<input type="text" id="casting cost input" value=""/><br>
			</div>
			<div id="creature menu">
				&nbsp<label><input type="checkbox" id="commander checkbox" />Commander</label><br>
			</div>
			<div id="common details menu">
				&nbspFlip Image URL:<br>
				&nbsp<input type="text" id="card back input" value=""/><br>
			</div>
		</div>
	</div>
	
	<!-- whitespace in the counter will mess it up because whitespace/text is considered a child node -->
	<div id="counter_container" numcounters="0">
		<div class="counter draggable" id="counter_template"><div class="value" onmousedown="dragCounter()">1</div><button class="increment btn" onclick="incrementCounter()">+</button><button class="decrement btn" onclick="decrementCounter()">-</button></div>
	</div>
	
	<script>
		var clickedElement;
		var cardWidth = 212; //156
		var cardHeight = 296; //222
		var nameHeight = 29; //22
		

		function toggleVisibility(element, displayType){
			var style = window.getComputedStyle(element);
			if(style.display == "none"){
				element.style.display = displayType||"block"; // welcome to javascript lol
			} else {
				element.style.display = "none";
			}
		}
	
		function togglePreferences(){
			var preferencesMenu = document.getElementById("preferences menu");
			var startingLife = document.getElementById("starting life");
			var cardSleeve = document.getElementById("card sleeve image");
			var playmatImage = document.getElementById("playmat image");
			startingLife.setAttribute("value", startingLife.value);
			cardSleeve.setAttribute("value", cardSleeve.value);
			playmatImage.setAttribute("value", playmatImage.value);
			toggleVisibility(preferencesMenu);
		}
		
		function incrementCounter(e){
			var sender = (e && e.target) || (window.event && window.event.srcElement);
			var counter = sender.parentNode;
			var input = counter.childNodes[0];
			input.innerHTML = parseInt(input.innerHTML)+1;
		}
		
		function decrementCounter(e){
			var sender = (e && e.target) || (window.event && window.event.srcElement);
			var counter = sender.parentNode;
			var input = counter.childNodes[0];
			input.innerHTML = parseInt(input.innerHTML)-1;
		}
		
		function dragCounter(e){
			var sender = (e && e.target) || (window.event && window.event.srcElement);
			var counter = sender.parentNode;
			clickedElement = counter;
			startDrag(e);
		}
		
		function addCounter(initialValue){
			var playmat = document.getElementById("playmat");
			var counterCont = document.getElementById("counter_container");
			var counterNumber = parseInt(counterCont.getAttribute("numcounters"));
			var counter = document.getElementById("counter_template").cloneNode(true);
			counter.id = "counter"+counterNumber;
			counter.style.left = 100 + 100*counterNumber + "px";
			counter.style.top = 100 + "px";
			counter.style.backgroundColor = "rgb("+parseInt(Math.random()*155+100)+","+parseInt(Math.random()*155+100)+","+parseInt(Math.random()*155+100)+")";
			playmat.appendChild(counter);
			counterCont.setAttribute("numcounters", counterNumber+1);
			if(initialValue && initialValue != 1){
				var input = counter.childNodes[0];
				input.innerHTML = initialValue;
			}
		}

		function deleteAllCounters()
		{
			var playmat = document.getElementById('playmat');
			var elementsOnMat = playmat.getElementsByTagName('*');
			var countersOnMat = []
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				if ( hasClass(elementsOnMat[i],'counter') && elementsOnMat[i].parentNode == playmat)
				{
					countersOnMat.push(elementsOnMat[i]);
				}
			}
			for (i = 0; i < countersOnMat.length; ++i)
			{
				countersOnMat[i].parentNode.removeChild(countersOnMat[i]);
			}
			document.getElementById("counter_container").setAttribute("numcounters","0");
		}

		function getXCoordOfMouse()
		{
			return window.event.x + document.body.scrollLeft - 2;
		}
		function getYCoordOfMouse()
		{
			return window.event.y + document.body.scrollTop - 2;
		}

		//Checks if an element has a particular class
		function hasClass(element, cls) {
		    return (' ' + element.className + ' ').indexOf(' ' + cls + ' ') > -1;
		}
		
		var enableDelayedHover = 0;
		var hoverEventId = 0;
		function startHoverOverCard()
		{
			enableDelayedHover = 1;
			hoverEventId++;
			if (hoverEventId >= 100) {
				hoverEventId = 0;
			}
			setTimeout(delayedHoverOverCard, 1000, hoverEventId);
		}

		var hoveredElement;
		function mouseEnterCard(e){
			// determine event object
			if (!e) {
				var e = window.event;
			}
			// IE uses srcElement, others use target
			hoveredElement = e.target ? e.target : e.srcElement;
			if (hasClass(hoveredElement, 'card')){
				startHoverOverCard();
			}
		}

		function mouseLeaveCard(e){
			// determine event object
			if (!e) {
				var e = window.event;
			}
			// IE uses srcElement, others use target
			var targetElement = e.target ? e.target : e.srcElement;
			enableDelayedHover = 0;
		}

		var mouseOverSideboard = false;
		function mouseEnterSideboard(e){
			mouseOverSideboard = true;
			console.log("in");
		}

		function mouseLeaveSideboard(e){
			mouseOverSideboard = false;
			console.log("out");
		}

		//
		function delayedHoverOverCard(triggeringHoverEventId){
			if (!drag && enableDelayedHover && triggeringHoverEventId == hoverEventId) {
				enableDelayedHover = 0;
				showCardInfoMenu(hoveredElement);
			}
		}

		//Handles mouseDown events
		
		var timeOfPreviousCardClick;
		var timeOfPreviousPreviousCardClick;
		var clickCounter = 0;
		function mouseDownCard(e){
			// determine event object
			if (!e) {
				var e = window.event;
			}
			// IE uses srcElement, others use target
			var tempClickedElement = e.target ? e.target : e.srcElement;
			//Prevent default behavior
			if(tempClickedElement.preventDefault) tempClickedElement.preventDefault();
			//If this is a different element, reset the click counter
			if ( tempClickedElement != clickedElement )
			{
				clickCounter = 0;
			}
			clickedElement = tempClickedElement;
			//Increment the click counter on this element
			++clickCounter;

			if (hasClass(clickedElement, 'card')){
				//console.log('click:' + clickCounter);
				//Set a delayed function to check for double and triple clicks
				setTimeout(evaluateNumClicks, 200, clickCounter);
				if (hasClass(clickedElement, 'sideboarded'))
				{
					//Move this to the playmat
					var playmat = document.getElementById('playmat');
					var sideboard = document.getElementById('sideboard');
					//Remove sideboarded class
					clickedElement.className = clickedElement.className.replace( /(?:^|\s)sideboarded(?!\S)/g , '' );
					//Put it on the playmat
					var rect = sideboard.getBoundingClientRect();
					console.log(rect.left);
					var documentScrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
					clickedElement.style.top = parseInt(clickedElement.style.top) + parseInt(rect.top) - sideboard.scrollTop + documentScrollTop + 'px';
					clickedElement.style.left= parseInt(clickedElement.style.left) + parseInt(rect.left) + 'px';
					playmat.appendChild(clickedElement);
				}
			}
			if (hasClass(clickedElement, 'draggable')){
				startDrag(e);
			}
			enableDelayedHover = 0;
		}

		var numClicks = 0;
		function evaluateNumClicks(triggeringClickCounter){
			//console.log('resolving click:' + triggeringClickCounter);
			//Are they trying to drag it?
			if (moved)
			{
				//Reset click counter
				numClicks = 0;
			}
			//Have they stopped clicking?
			else if (clickCounter == triggeringClickCounter)
			{
				//Count this click
				++numClicks
				//Resolve the proper action
				if (numClicks == 1)
				{
					//Single click = Tap/Untap
					tapOrUntapCard(clickedElement);
				}
				else if (numClicks == 2)
				{
					//Double click = Flip
					flipCard(clickedElement);
				}
				//Reset click counter
				numClicks = 0;
			} else {
				//They haven't stopped clicking. Increment the click counter without resolving
				numClicks++;
			}
		}

		function mouseUpCard(e){
			// determine event object
			if (!e) {
				var e = window.event;
			}
			// IE uses srcElement, others use target
			hoveredElement = e.target ? e.target : e.srcElement;
			if (hasClass(hoveredElement, 'card')){
				startHoverOverCard();
			}
		}

		//Prepares to drag the element
		var startCoordX;
		var startCoordY;
		var endCoordX;
		var endCoordY;
		var select = false;
		function startSelection(e) {
			// determine event object
			if (!e) {
				var e = window.event;
			}

			var playmat = document.getElementById("playmat");

			//Prevent default behavior
			if(playmat.preventDefault)
			{
				playmat.preventDefault();
			}

			//Check that they weren't clicking on something else
			var targetElement = e.target ? e.target : e.srcElement;
			if(playmat == targetElement)
			{
				deselectAll();

				// calculate event X, Y coordinates
				startCoordX = getXCoordOfMouse();
				startCoordY = getYCoordOfMouse();

				var selector = document.getElementById("selector");
				selector.style.top = startCoordY + 'px';
				selector.style.left = startCoordX + 'px';
				selector.style.width = '0px';
				selector.style.height = '0px';
				selector.className = 'blue_selector';
				
				// enable moving selector element when the mouse moves
				select = true;
			}
            return false;
		}

		//Prepares to drag the element
		var coordX;
		var coordY;
		var drag = false;
		var moved = false;
		var elementToDrag;
		function startDrag(e) {

			//Did they click on a selected element?
			if (hasClass(clickedElement, 'selected'))
			{
				//Drag the whole selection
				elementToDrag = document.getElementById('selector');
			} else {
				//Drag just the element that was clicked
				elementToDrag = clickedElement;
				//Bring the element to the front
				elementToDrag.parentNode.appendChild(elementToDrag);
			}

			// calculate event X, Y coordinates
			offsetX = window.event.x;
			offsetY = window.event.y;

			// assign default values for top and left properties
			if(!elementToDrag.style.left) { elementToDrag.style.left='0px'};
			if (!elementToDrag.style.top) { elementToDrag.style.top='0px'};

			// calculate integer values for top and left 
			// properties
			coordX = parseInt(elementToDrag.style.left);
			coordY = parseInt(elementToDrag.style.top);
			

			// enable moving div element
			drag = true;
			moved = false;
            return false;
		}

		//Called whenever the mouse moves on the document, so make this fast
		function dragElement(e) {
			//If the user is currently dragging an element
			if (drag)
			{
				if (!e) { var e= window.event};
				// var targ=e.target?e.target:e.srcElement;
				// move div element
				if (hasClass(elementToDrag,'sideboarded'))
				{
					elementToDrag.style.left=coordX+e.clientX-offsetX+'px';
					elementToDrag.style.top=coordY+e.clientY-offsetY+'px';
				} else {
					if (coordX+e.clientX-offsetX < 0){
						elementToDrag.style.left='0px';
					} else {
						elementToDrag.style.left=coordX+e.clientX-offsetX+'px';
					}
					if (coordY+e.clientY-offsetY < 0){
						elementToDrag.style.top='0px';
					} else {
						elementToDrag.style.top=coordY+e.clientY-offsetY+'px';
					}
				}
				
				if ((e.clientX-offsetX) != 0 || (e.clientY-offsetY) != 0)
				{
					moved = true;
				}
				hideSelector();
				select = false;
			//Else, if the user is currently trying to select things
			} else if (select) {
				var selector = document.getElementById("selector");
				//Get the current mouse position
				endCoordX = getXCoordOfMouse();
				endCoordY = getYCoordOfMouse();
				//Update the selection box's Y position and height to span the start and end coords
				if (startCoordY < endCoordY)
				{
					selector.style.top = startCoordY + 'px';
					selector.style.height = (endCoordY - startCoordY) + 'px'
				} else {
					selector.style.top = endCoordY + 'px';
					selector.style.height = (startCoordY - endCoordY) + 'px'
				}
				//Update the selection box's X position and width to span the start and end coords
				if (startCoordX < endCoordX)
				{
					selector.style.left = startCoordX + 'px';
					selector.style.width = (endCoordX - startCoordX) + 'px'
					//If the user is selecting to the right, use blue selection box
					selector.className = "blue_selector";
				} else {
					selector.style.left = endCoordX + 'px';
					selector.style.width = (startCoordX - endCoordX) + 'px'
					//If the user is selecting to the left, use green selection box
					selector.className = "green_selector";
				}
			}
			return false;
		}

		//Make the selection box transparent
		function hideSelector() {
			var selector = document.getElementById('selector');
			selector.className = 'invisible_selector';
			selector.style.width = '0px';
			selector.style.height = '0px';
		}

		//Move all listed elements into the "selected" div, and add the 'selected' class
		function groupSelectedElements(selectedElements) {
			if (selectedElements.length > 0)
			{
				var i;
				var selector = document.getElementById('selector');
				//Tighten the top and left of the selector to the selected elements
				//That way when the selection gets dragged it gets stopped at a reasonable
				//position when the top or left of the page is hit.
				var minTop = parseInt(selectedElements[0].style.top);
				var minLeft = parseInt(selectedElements[0].style.left);
				for (i = 1; i < selectedElements.length; ++i)
				{
					if (parseInt(selectedElements[i].style.top) < minTop )
					{
						minTop = parseInt(selectedElements[i].style.top);
					}
					if (parseInt(selectedElements[i].style.left) < minLeft )
					{
						minLeft = parseInt(selectedElements[i].style.left);
					}
				}
				selector.style.top = minTop + 'px';
				selector.style.left = minLeft + 'px';
				//Now move the elements into the selector div
				for (i = 0; i < selectedElements.length; ++i)
				{
					//Also add a class so they look like they are selected
					selectedElements[i].className += ' selected';
					selectedElements[i].style.top = parseInt(selectedElements[i].style.top) - parseInt(selector.style.top) + 'px';
					selectedElements[i].style.left= parseInt(selectedElements[i].style.left) - parseInt(selector.style.left) + 'px';
					selector.appendChild(selectedElements[i]);
				}
				document.getElementById("shuffle button").style.visibility = 'visible';
				document.getElementById("stack button").style.visibility = 'visible';
				document.getElementById("delete selection button").style.visibility = 'visible';
				document.getElementById("new game button").style.visibility = 'hidden';
				document.getElementById("cost sort button").style.visibility = 'hidden';
				document.getElementById("color sort button").style.visibility = 'hidden';
				document.getElementById("type sort button").style.visibility = 'hidden';
				document.getElementById("purpose sort button").style.visibility = 'hidden';
			}
		}

		//Remove all selected elements from the "selected" div, unset their style, and empty the array of selected elements
		function deselectAll()
		{
			var i = 0;
			var playmat = document.getElementById('playmat');
			var selector = document.getElementById('selector');
			var selectedElements = [];
			var elementsInSelector = selector.getElementsByTagName('*');
			for (i = 0; i < elementsInSelector.length; ++i)
			{
				//Check that this is a top-level element
				if (elementsInSelector[i].parentNode == selector)
				{
					selectedElements.push(elementsInSelector[i]);
				}
			}
			for (i = 0; i < selectedElements.length; ++i)
			{
				selectedElements[i].style.top = parseInt(selectedElements[i].style.top) + parseInt(selector.style.top) + 'px';
				selectedElements[i].style.left= parseInt(selectedElements[i].style.left) + parseInt(selector.style.left) + 'px';
				playmat.appendChild(selectedElements[i]);
			}
			for (i = 0; i < selectedElements.length; ++i)
			{
				selectedElements[i].className = selectedElements[i].className.replace( /(?:^|\s)selected(?!\S)/g , '' )
			}
			document.getElementById("shuffle button").style.visibility = 'hidden';
			document.getElementById("stack button").style.visibility = 'hidden';
			document.getElementById("delete selection button").style.visibility = 'hidden';
			document.getElementById("new game button").style.visibility = 'visible';
			document.getElementById("cost sort button").style.visibility = 'visible';
			document.getElementById("color sort button").style.visibility = 'visible';
			document.getElementById("type sort button").style.visibility = 'visible';
			document.getElementById("purpose sort button").style.visibility = 'visible';
		}

		//Called whenever the mouse button goes up on the document
		function stopDrag() {
			if (drag)
			{
				drag=false;
				var playmat = document.getElementById("playmat");
				var sideboard = document.getElementById("sideboard");

				//the sideboard is visible and it was dropped in the sideboard
				if (mouseOverSideboard && sideboard.style.visibility == 'visible')
				{
					//If the dragged element is a card and the sideboard is visible and it was dropped in the sideboard
					if (hasClass(elementToDrag, 'card'))
					{
						if (!hasClass(elementToDrag, 'sideboarded'))
						{
							elementToDrag.className += ' sideboarded';
						}
						sideboard.appendChild(elementToDrag);
						sortSideboard();
					} else if (elementToDrag.id == 'selector' ) {
						//If the selection is being dragged
						var selectedElements = [];
						var elementsInSelector = elementToDrag.getElementsByTagName('*');
						for (i = 0; i < elementsInSelector.length; ++i)
						{
							//Check that this is a top-level element
							if (elementsInSelector[i].parentNode == elementToDrag)
							{
								selectedElements.push(elementsInSelector[i]);
							}
						}
						for (i = 0; i < selectedElements.length; ++i)
						{
							selectedElements[i].className = selectedElements[i].className.replace( /(?:^|\s)selected(?!\S)/g , '' )
							if (!hasClass(selectedElements[i], 'sideboarded'))
							{
								selectedElements[i].className += ' sideboarded';
							}
						}
						for (i = 0; i < selectedElements.length; ++i)
						{
							sideboard.appendChild(selectedElements[i]);
						}
						sortSideboard();
						deselectAll();
					}
				}


				//Set document size to extent of interior elements
				document.body.style.width = '100%';
				document.body.style.height = '100%';
				document.body.style.width = document.body.scrollWidth + 'px';
				document.body.style.height = document.body.scrollHeight + 'px';
			}
			
			if (select)
			{
				var selector = document.getElementById("selector");
				//Go through all cards and check if they are being selected
				var playmat = document.getElementById("playmat");
				var elementsOnMat = playmat.getElementsByTagName('*');

				var i, element;
				var topBoundary = parseInt(selector.style.top);
				var leftBoundary = parseInt(selector.style.left);
				var bottomBoundary = topBoundary + parseInt(selector.style.height);
				var rightBoundary = leftBoundary + parseInt(selector.style.width);
				var elementTop = 0;
				var elementLeft = 0;
				var elementBottom = 0;
				var elementRight = 0;
				var elementStyle;
				var i = 0;

				var selectedElements = new Array();
				if (selector.className == "blue_selector")
				{
					hideSelector();
					//Blue selector only selects elements that are entirely within the selection box	
					for (i = 0; i < elementsOnMat.length; ++i)
					{
						//Check that this is a top-level element
						if (elementsOnMat[i].parentNode == playmat)
						{
							elementStyle = window.getComputedStyle(elementsOnMat[i]);
							elementTop = parseInt(elementsOnMat[i].style.top);
							elementLeft = parseInt(elementsOnMat[i].style.left);
							elementRight = elementLeft + parseInt(elementStyle.width);
							elementBottom = elementTop + parseInt(elementStyle.height);

							//Check its coordinates
							if (elementTop >= topBoundary &&
								elementLeft >= leftBoundary &&
								elementBottom <= bottomBoundary &&
								elementRight <= rightBoundary)
							{
								selectedElements.push(elementsOnMat[i]);
							}
						}
					}
				} else if (selector.className == "green_selector"){
					hideSelector();
					//Green selector slects any elements that overlap the selection box
					for (i = 0; i < elementsOnMat.length; ++i)
					{
						//Check that this is a top-level element
						if (elementsOnMat[i].parentNode == playmat)
						{
							elementStyle = window.getComputedStyle(elementsOnMat[i]);
							elementTop = parseInt(elementsOnMat[i].style.top);
							elementLeft = parseInt(elementsOnMat[i].style.left);
							elementRight = elementLeft + parseInt(elementStyle.width);
							elementBottom = elementTop + parseInt(elementStyle.height);
							//Check its coordinates
							if (elementLeft <= rightBoundary &&
								elementRight >= leftBoundary &&
								elementTop <= bottomBoundary &&
								elementBottom >= topBoundary )
							{
								selectedElements.push(elementsOnMat[i]);
							}
						}
					}
				}
				//Move the selected elements to the "selected" div for O(1) movement
				groupSelectedElements(selectedElements);
				
				select = false
			}
		}

		var selectedCard;
		function showCardInfoMenu(element) {
			if (hasClass(element, 'card')){
				selectedCard = element;
				if (hasClass(element, 'selected'))
				{
					var selector = document.getElementById('selector');
					document.getElementById('card info popup').style.top = parseInt(selectedCard.style.top) - 5 + parseInt(selector.style.top)  + 'px';
					document.getElementById('card info popup').style.left = parseInt(selectedCard.style.left) - 5 + parseInt(selector.style.left) + 'px';
				} else {
					document.getElementById('card info popup').style.top = parseInt(selectedCard.style.top) - 5 + 'px';
					document.getElementById('card info popup').style.left = parseInt(selectedCard.style.left) - 5 + 'px';
				}
				hideEditCard();
				document.getElementById('magnified card view').src = selectedCard.src;
				document.getElementById('card info popup').style.visibility = 'visible';
			}
		}

		function hideCardInfoMenu() {
			hideEditCard();
			document.getElementById('card info popup').style.visibility = 'hidden';
		}

		function loadEditCardSettings()
		{
			//Load the settings
			document.getElementById('card name input').value = selectedCard.getAttribute('name');
			document.getElementById('purpose input').value = selectedCard.getAttribute('purpose');
			document.getElementById('land checkbox').checked = selectedCard.getAttribute('land') == 'true';
			document.getElementById('creature checkbox').checked = selectedCard.getAttribute('creature') == 'true';
			document.getElementById('planeswalker checkbox').checked = selectedCard.getAttribute('planeswalker') == 'true';
			document.getElementById('artifact checkbox').checked = selectedCard.getAttribute('artifact') == 'true';
			document.getElementById('enchantment checkbox').checked = selectedCard.getAttribute('enchantment') == 'true';
			document.getElementById('sorcery checkbox').checked = selectedCard.getAttribute('sorcery') == 'true';
			document.getElementById('instant checkbox').checked = selectedCard.getAttribute('instant') == 'true';
			document.getElementById('casting cost input').value = selectedCard.getAttribute('casting_cost');
			document.getElementById('commander checkbox').checked = selectedCard.getAttribute('commander') == 'true';
			var manaProductionBitVector = parseInt(selectedCard.getAttribute('mana_production_bitvector'));
			document.getElementById('produces white checkbox').checked = manaProductionBitVector & 0x01;
			document.getElementById('produces blue checkbox').checked = manaProductionBitVector & 0x02;
			document.getElementById('produces black checkbox').checked = manaProductionBitVector & 0x04;
			document.getElementById('produces red checkbox').checked = manaProductionBitVector & 0x08;
			document.getElementById('produces green checkbox').checked = manaProductionBitVector & 0x10;
			document.getElementById('produces colorless checkbox').checked = manaProductionBitVector & 0x20;
			document.getElementById('card back input').value = selectedCard.getAttribute('back');
		}

		function saveEditCardSettings()
		{
			selectedCard.setAttribute('name', document.getElementById('card name input').value );
			selectedCard.setAttribute('purpose', document.getElementById('purpose input').value );
			selectedCard.setAttribute('land', document.getElementById('land checkbox').checked );
			selectedCard.setAttribute('creature', document.getElementById('creature checkbox').checked );
			selectedCard.setAttribute('planeswalker', document.getElementById('planeswalker checkbox').checked );
			selectedCard.setAttribute('artifact', document.getElementById('artifact checkbox').checked );
			selectedCard.setAttribute('enchantment', document.getElementById('enchantment checkbox').checked );
			selectedCard.setAttribute('sorcery', document.getElementById('sorcery checkbox').checked );
			selectedCard.setAttribute('instant', document.getElementById('instant checkbox').checked );
			selectedCard.setAttribute('casting_cost', document.getElementById('casting cost input').value);
			selectedCard.setAttribute('commander', document.getElementById('commander checkbox').checked );
			var manaProductionBitVector = 0;
			if (document.getElementById('produces white checkbox').checked) { manaProductionBitVector |= 0x01;}
			if (document.getElementById('produces blue checkbox').checked) { manaProductionBitVector |= 0x02;}
			if (document.getElementById('produces black checkbox').checked) { manaProductionBitVector |= 0x04;}
			if (document.getElementById('produces red checkbox').checked) { manaProductionBitVector |= 0x08;}
			if (document.getElementById('produces green checkbox').checked) { manaProductionBitVector |= 0x10;}
			if (document.getElementById('produces colorless checkbox').checked) { manaProductionBitVector |= 0x20;}
			selectedCard.setAttribute('mana_production_bitvector', manaProductionBitVector );
			selectedCard.setAttribute('back', document.getElementById('card back input').value );
		}

		function hideEditCard()
		{
			//Check if the user made changes
			if (document.getElementById("edit card control panel").style.visibility == 'visible')
			{
				//Hide the edit card control panel and save the settings
				saveEditCardSettings();
				document.getElementById('land menu').style.visibility = 'hidden';
				document.getElementById('nonland menu').style.visibility = 'hidden';
				document.getElementById('creature menu').style.visibility = 'hidden';
				document.getElementById("edit card control panel").style.visibility = 'hidden';
			}
		}

		function viewEditCard()
		{
			//Load the settings and make the edit card control panel visible
			loadEditCardSettings();
			updateEditCardFormByType();
			document.getElementById("edit card control panel").style.visibility = 'visible';
		}

		function toggleEditCard()
		{
			//If the edit card panel was visible, hide it and save settings
			if (document.getElementById("edit card control panel").style.visibility == 'visible')
			{
				hideEditCard();
			}
			else
			{
				viewEditCard();
			}
		}

		function updateEditCardFormByType()
		{
			var landMenuElement = document.getElementById('land menu');
			var nonlandMenuElement = document.getElementById('nonland menu');
			var creatureMenuElement = document.getElementById('creature menu');
			var commonDetailsMenuElement = document.getElementById('common details menu');
			//Is this a land?
			if (document.getElementById('land checkbox').checked)
			{
				//Show land stuff
				landMenuElement.style.visibility = 'visible';
				landMenuElement.parentNode.appendChild(landMenuElement);
				//Is this a creature?
				if (document.getElementById('creature checkbox').checked)
				{
					creatureMenuElement.style.visibility = 'visible';	//In case they print a legendary land creature, so that it can be your commander
					//Append this next
					creatureMenuElement.parentNode.appendChild(creatureMenuElement);
					commonDetailsMenuElement.parentNode.appendChild(commonDetailsMenuElement);
				} else {
					creatureMenuElement.style.visibility = 'hidden';
					//Move hidden elements to bottom so there isn't a blank space
					commonDetailsMenuElement.parentNode.appendChild(commonDetailsMenuElement);
					creatureMenuElement.parentNode.appendChild(creatureMenuElement);
				}
				//move hidden elements to bottom so there isn't a blank space
				nonlandMenuElement.style.visibility = 'hidden';
				nonlandMenuElement.parentNode.appendChild(nonlandMenuElement);
			}
			else
			{
				//Is this a creature, planeswalker, artifact, or enchantment
				if (document.getElementById('creature checkbox').checked || document.getElementById('planeswalker checkbox').checked || document.getElementById('artifact checkbox').checked || document.getElementById('enchantment checkbox').checked)
				{
					nonlandMenuElement.style.visibility = 'visible';
					nonlandMenuElement.parentNode.appendChild(nonlandMenuElement);
					//Is this a creature?
					if (document.getElementById('creature checkbox').checked)
					{
						creatureMenuElement.style.visibility = 'visible';
						//Move hidden elements to bottom so there isn't a blank space
						creatureMenuElement.parentNode.appendChild(creatureMenuElement);
						commonDetailsMenuElement.parentNode.appendChild(commonDetailsMenuElement);
					} else {
						creatureMenuElement.style.visibility = 'hidden';
						//Move hidden elements to bottom so there isn't a blank space
						commonDetailsMenuElement.parentNode.appendChild(commonDetailsMenuElement);
						creatureMenuElement.parentNode.appendChild(creatureMenuElement);
					}
				}
				else if (document.getElementById('sorcery checkbox').checked || document.getElementById('instant checkbox').checked)
				{
					nonlandMenuElement.style.visibility = 'visible';
					creatureMenuElement.style.visibility = 'hidden';
					nonlandMenuElement.parentNode.appendChild(nonlandMenuElement);
					//Move hidden elements to bottom so there isn't a blank space
					commonDetailsMenuElement.parentNode.appendChild(commonDetailsMenuElement);
					creatureMenuElement.parentNode.appendChild(creatureMenuElement);
				}
				else
				{
					nonlandMenuElement.style.visibility = 'hidden';
					creatureMenuElement.style.visibility = 'hidden';
					//Move hidden elements to bottom so there isn't a blank space
					commonDetailsMenuElement.parentNode.appendChild(commonDetailsMenuElement);
					nonlandMenuElement.parentNode.appendChild(nonlandMenuElement);
					creatureMenuElement.parentNode.appendChild(creatureMenuElement);
				}
				//Hide land stuff
				landMenuElement.style.visibility = 'hidden';
				landMenuElement.parentNode.appendChild(landMenuElement);
			}
		}

		function permanentTypeSelected()
		{
			document.getElementById('sorcery checkbox').checked = false;
			document.getElementById('instant checkbox').checked = false;
			updateEditCardFormByType();
		}

		function instantTypeSelected()
		{
			document.getElementById('land checkbox').checked = false;
			document.getElementById('creature checkbox').checked = false;
			document.getElementById('planeswalker checkbox').checked = false;
			document.getElementById('artifact checkbox').checked = false;
			document.getElementById('enchantment checkbox').checked = false;
			document.getElementById('sorcery checkbox').checked = false;
			updateEditCardFormByType();
		}

		function sorceryTypeSelected()
		{
			document.getElementById('land checkbox').checked = false;
			document.getElementById('creature checkbox').checked = false;
			document.getElementById('planeswalker checkbox').checked = false;
			document.getElementById('artifact checkbox').checked = false;
			document.getElementById('enchantment checkbox').checked = false;
			document.getElementById('instant checkbox').checked = false;
			updateEditCardFormByType();
		}		

		var CardElement = function(imagesource) {
			this.element = document.createElement("img");
			this.element.src = imagesource;
			this.element.className = "draggable card";
			this.element.setAttribute("name", "");
			this.element.setAttribute("purpose", "");
			this.element.setAttribute("front", imagesource);
			this.element.setAttribute("back", "");
			this.element.setAttribute("land", false);
			this.element.setAttribute("creature", false);
			this.element.setAttribute("planeswalker", false);
			this.element.setAttribute("artifact", false);
			this.element.setAttribute("enchantment", false);
			this.element.setAttribute("sorcery", false);
			this.element.setAttribute("instant", false);
			this.element.setAttribute("casting_cost", "");
			this.element.setAttribute("commander", false);
			this.element.setAttribute('mana_production_bitvector', "0");
			this.element.style.top = '0px';
			this.element.style.left = '0px';
			this.element.addEventListener("mousedown", mouseDownCard);
			this.element.addEventListener("mouseup", mouseUpCard);
			this.element.addEventListener("mouseenter", mouseEnterCard);
			this.element.addEventListener("mouseleave", mouseLeaveCard);
			document.getElementById("playmat").appendChild(this.element);
			return this.element;
		}

		function padToFour(number) {
		  if (number<=9999) { number = ("000"+number).slice(-4); }
		  return number;
		}

		function addCard() {
			var cardImageUrlString = String(document.getElementById("cardimageurl").value);
			var urlRegex =/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
			var numCardsAdded = 0;
			var padding = 5;
		    cardImageUrlString.replace(urlRegex, function(url) {
		    	var newCard = CardElement(url);
		    	newCard.style.top = Math.floor(numCardsAdded / 10) * (cardHeight + padding) + 25 + 'px';
		    	newCard.style.left = (numCardsAdded % 10) * (cardWidth + padding) + 25 + 'px';
		    	newCard.setAttribute("name", padToFour(numCardsAdded));
		    	numCardsAdded = numCardsAdded + 1;
		        return url;
		    });
		}

		function copyCard() {
			var clone = selectedCard.cloneNode(true);
			clone.addEventListener("mousedown", mouseDownCard);
			clone.addEventListener("mouseup", mouseUpCard);
			clone.addEventListener("mouseenter", mouseEnterCard);
			clone.addEventListener("mouseleave", mouseLeaveCard);
			selectedCard.parentNode.appendChild(clone);
		}

		function deleteCard() {
			document.getElementById('magnified card view').src = "";
			hideCardInfoMenu();
			selectedCard.parentNode.removeChild(selectedCard);
		}

		function clearCardImageUrlEntry() {
			document.getElementById("cardimageurl").value = "";
		}

		function tapOrUntapCard(element) {
			//Is the card sideboarded?
			if (!hasClass(element, 'sideboarded'))
			{
				//Is the card already tapped?
				if (hasClass(element, 'rotated')){
					//Is the card part of a selection?
					if (hasClass(element, 'selected'))
					{
						//Untap all cards in the selection
						var elementsInSelector = document.getElementById('selector').getElementsByTagName('*');
						var i;
						for (i = 0; i < elementsInSelector.length; ++i)
						{
							if (hasClass(elementsInSelector[i],"card"))
							{
								elementsInSelector[i].className = elementsInSelector[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
							}
						}
					}
					else
					{
						//Untap just this card
						element.className = element.className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
					}
				} else {
					//Is the card part of a selection?
					if (hasClass(element, 'selected'))
					{
						//Tap all cards in the selection
						var elementsInSelector = document.getElementById('selector').getElementsByTagName('*');
						var i;
						for (i = 0; i < elementsInSelector.length; ++i)
						{
							if (hasClass(elementsInSelector[i],"card"))
							{
								if (!hasClass(elementsInSelector[i], 'rotated'))
								{
									elementsInSelector[i].className += ' rotated';
								}
							}
						}
					}
					else
					{
						//Tap just this card
						element.className += ' rotated';
					}
				}
			}
		}

		function flipCard(element)
		{
			//Is this card part of a selection?
			if (hasClass(element, 'selected'))
			{
				var elementsInSelector = document.getElementById('selector').getElementsByTagName('*');
				var i;
				//Is the card face up?
				if (element.src == element.getAttribute("front"))
				{
					//Is this a double-faced card?
					if (element.getAttribute("back") != "")
					{
						//Transform all transformable cards
						for (i = 0; i < elementsInSelector.length; ++i)
						{
							if (hasClass(elementsInSelector[i],"card"))
							{
								//Is this a transformable card?
								if (elementsInSelector[i].getAttribute("back") != "")
								{
									elementsInSelector[i].src = elementsInSelector[i].getAttribute("back");
								}
							}
						}
					}
					else
					{
						//Conceal all cards
						for (i = 0; i < elementsInSelector.length; ++i)
						{
							if (hasClass(elementsInSelector[i],"card"))
							{
								elementsInSelector[i].src = document.getElementById("card sleeve image").value;
							}
						}
					}
				}
				else
				{
					//flip all cards to front side
					for (i = 0; i < elementsInSelector.length; ++i)
					{
						if (hasClass(elementsInSelector[i],"card"))
						{
							elementsInSelector[i].src = elementsInSelector[i].getAttribute("front");
						}
					}
				}
			}
			else
			{
				//Is the card face up?
				if (element.src == element.getAttribute("front"))
				{
					//Is this a double-faced card?
					if (element.getAttribute("back") != "")
					{
						//Double-faced card, transform
						element.src = element.getAttribute("back");
					} else {
						//Conceal this card
						element.src = document.getElementById("card sleeve image").value;
					}
				}
				else
				{
					//flip to front side
					element.src = element.getAttribute("front");
				}
			}
		}

		function shuffle()
		{
			var xOffset = 0;
			var yOffset = 0;

			//Are any cards selected?
			var elementsToShuffle = document.getElementById('selector').getElementsByTagName('*');

			//Figure out which of the elements are cards
			var cardsToShuffle = [];
			var i = 0;
			for (i = 0; i < elementsToShuffle.length; ++i)
			{
				if (hasClass(elementsToShuffle[i], "card"))
				{
					cardsToShuffle.push(elementsToShuffle[i]);
				}
			}

			//Shuffle the cards
			var numCards = cardsToShuffle.length;
			
			for (i = 0; i < numCards; ++i)
			{
				//Select a card at random
				var index = Math.floor(Math.random() * cardsToShuffle.length);
				//Conceal the card
				cardsToShuffle[index].src = document.getElementById("card sleeve image").value;
				//Put it into the deck
				cardsToShuffle[index].style.top = yOffset + i + 'px';
				cardsToShuffle[index].style.left = xOffset + i + 'px';
				cardsToShuffle[index].className = cardsToShuffle[index].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				//Bring it in front of the other elements
				cardsToShuffle[index].parentNode.appendChild(cardsToShuffle[index]);
				//Remove it from the list of cards to be shuffled
				cardsToShuffle.splice(index,1);
			}

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';
		}

		function newGame()
		{
			//Get all the elements on the playmat
			var elementsToShuffle = document.getElementById('playmat').getElementsByTagName('*');
			var xOffset = 400;
			var yOffset = 700;
			deleteAllCounters();
			addCounter(parseInt(document.getElementById("starting life").value));
			addCounter(parseInt(document.getElementById("starting life").value));
			
			//Figure out which of the elements are non-commander cards
			var cardsToShuffle = [];
			var i = 0;
			for (i = 0; i < elementsToShuffle.length; ++i)
			{
				if (hasClass(elementsToShuffle[i], "card") && elementsToShuffle[i].getAttribute('commander') != 'true')
				{
					cardsToShuffle.push(elementsToShuffle[i]);
				}
			}

			//Count how many cards we need to shuffle
			var numCards = cardsToShuffle.length;

			//Draw a hand of 7 cards
			for (i = 0; i < 7 && i < numCards; ++i)
			{
				//Select a card at random
				var index = Math.floor(Math.random() * cardsToShuffle.length);
				//Reveal the card
				cardsToShuffle[index].src = cardsToShuffle[index].getAttribute("front");
				//Put it below the deck
				cardsToShuffle[index].style.top = yOffset + numCards + cardHeight + 10 + 'px';
				cardsToShuffle[index].style.left = 10 + i * (cardWidth + 10) + 'px';
				cardsToShuffle[index].className = cardsToShuffle[index].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				//Bring it in front of the other elements
				cardsToShuffle[index].parentNode.appendChild(cardsToShuffle[index]);
				//Remove it from the list of cards to be shuffled
				cardsToShuffle.splice(index,1);
			}

			//Shuffle the remaining cards
			for (; i < numCards; ++i)
			{
				//Select a card at random
				var index = Math.floor(Math.random() * cardsToShuffle.length);
				//Conceal the card
				cardsToShuffle[index].src = document.getElementById("card sleeve image").value;
				//Put it into the deck
				cardsToShuffle[index].style.top = yOffset + i + 'px';
				cardsToShuffle[index].style.left = xOffset + i + 'px';
				cardsToShuffle[index].className = cardsToShuffle[index].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				//Bring it in front of the other elements
				cardsToShuffle[index].parentNode.appendChild(cardsToShuffle[index]);
				//Remove it from the list of cards to be shuffled
				cardsToShuffle.splice(index,1);
			}

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';
		}

		function toggleSideboard()
		{
			var sideboard = document.getElementById('sideboard');
			if (sideboard.style.visibility == 'visible')
			{
				sideboard.style.visibility = 'hidden';
			} else {
				sideboard.style.visibility = 'visible';
			}
		}

		function stack()
		{
			//Are any cards selected?
			var elementsToStack = document.getElementById('selector').getElementsByTagName('*');

			//Figure out which of the elements are non-commander cards
			var cardsToStack = [];
			var i = 0;
			for (i = 0; i < elementsToStack.length; ++i)
			{
				if (hasClass(elementsToStack[i], "card") )
				{
					cardsToStack.push(elementsToStack[i]);
				}
			}

			//Stack the cards
			var xOffset = 0;
			var yOffset = 0;
			
			
			for (i = 0; i < cardsToStack.length; ++i)
			{
				//Put it into the stack
				cardsToStack[i].style.top = yOffset + 'px';
				cardsToStack[i].style.left = xOffset + 'px';
				//Is this card concealed?
				if (cardsToStack[i].src == document.getElementById("card sleeve image").value)
				{
					xOffset = xOffset + 1;
					yOffset = yOffset + 1;
				} else {
					yOffset = yOffset + nameHeight;
				}
			}

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';
		}

		var ManaCost = function(manaCostString)
		{
			this.generic = 0;
			this.w = 0;
			this.u = 0;
			this.b = 0;
			this.r = 0;
			this.g = 0;
			this.c = 0;
			this.wu = 0;
			this.ub = 0;
			this.br = 0;
			this.rg = 0;
			this.gw = 0;
			this.wb = 0;
			this.ur = 0;
			this.bg = 0;
			this.rw = 0;
			this.gu = 0;
			this.h2w = 0;
			this.h2u = 0;
			this.h2b = 0;
			this.h2r = 0;
			this.h2g = 0;
			this.total = 0;
			this.colorBitVector = 0;

			if(manaCostString != null)
			{
				var lc_manaCostString = manaCostString.toLowerCase();
				for (var c = 0; c < lc_manaCostString.length; ++c)
				{
					//Is this character a number?
					if (lc_manaCostString.charCodeAt(c) >= "0".charCodeAt(0) &&
						lc_manaCostString.charCodeAt(c) <= "9".charCodeAt(0))
					{
						//Add this digit to the running generic mana cost
						this.generic = this.generic * 10 + lc_manaCostString.charCodeAt(c) - "0".charCodeAt(0);
					} else if (lc_manaCostString[c] == 'w') {
						this.w++;
						this.colorBitVector |= 0x01;
					} else if (lc_manaCostString[c] == 'u') {
						this.u++;
						this.colorBitVector |= 0x02;
					} else if (lc_manaCostString[c] == 'b') {
						this.b++;
						this.colorBitVector |= 0x04;
					} else if (lc_manaCostString[c] == 'r') {
						this.r++;
						this.colorBitVector |= 0x08;
					} else if (lc_manaCostString[c] == 'g') {
						this.g++;
						this.colorBitVector |= 0x10;
					} else if (lc_manaCostString[c] == 'c') {
						this.c++;
						this.colorBitVector |= 0x20;
					} else if (lc_manaCostString[c] == '{' && (c+5) <= lc_manaCostString.length) {
						var substring = lc_manaCostString.substring(c,c+5);
						if ( substring       == "{w/u}") {
							this.wu++;
							this.colorBitVector |= 0x03;
						} else if (substring == "{u/b}") {
							this.ub++;
							this.colorBitVector |= 0x06;
						} else if (substring == "{b/r}") {
							this.br++;
							this.colorBitVector |= 0x0C;
						} else if (substring == "{r/g}") {
							this.rg++;
							this.colorBitVector |= 0x18;
						} else if (substring == "{g/w}") {
							this.gw++;
							this.colorBitVector |= 0x11;
						} else if (substring == "{w/b}") {
							this.wb++;
							this.colorBitVector |= 0x05;
						} else if (substring == "{u/r}") {
							this.ur++;
							this.colorBitVector |= 0x0A;
						} else if (substring == "{b/g}") {
							this.bg++;
							this.colorBitVector |= 0x14;
						} else if (substring == "{r/w}") {
							this.rw++;
							this.colorBitVector |= 0x09;
						} else if (substring == "{g/u}") {
							this.gu++;
							this.colorBitVector |= 0x12;
						} else if (substring == "{2/w}") {
							this.h2w++;
							this.colorBitVector |= 0x01;
						} else if (substring == "{2/u}") {
							this.h2u++;
							this.colorBitVector |= 0x02;
						} else if (substring == "{2/b}") {
							this.h2b++;
							this.colorBitVector |= 0x04;
						} else if (substring == "{2/r}") {
							this.h2r++;
							this.colorBitVector |= 0x08;
						} else if (substring == "{2/g}") {
							this.h2g++;
							this.colorBitVector |= 0x10;
						}
						c += 4;
					}
				}
				this.total = this.generic + this.w + this.u + this.b + this.r + this.g + this.c + this.wu + this.ub + this.br + this.rg + this.gw + this.wb + this.ur + this.bg + this.rw + this.gu + this.h2w + this.h2u + this.h2b + this.h2r + this.h2g;
			}
		}

		function getTotalCost(cardElement)
		{
			if (cardElement.getAttribute('land') == 'true')
			{
				return -1;
			} else {
				var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
				return cost.total;
			}
		}

		colorOrderLookupTable = [ 1,  2,  3,  7,  4, 12,  8, 17, 5, 16, 15, 22,  9, 24, 18, 31, 6, 11, 14, 21, 13, 26, 23, 30, 10, 20, 25, 29, 19, 28, 27, 32, 33, 34, 35, 39, 36, 44, 40, 49, 37, 48, 47, 54, 41, 56, 50, 63, 38, 43, 46, 53, 45, 58, 55, 62, 42, 52, 57, 61, 51, 60, 59, 64];
		

		function getColorOrder(cardElement)
		{
			if (cardElement.getAttribute('land') == 'true')
			{
				var manaProductionBitVector = parseInt(cardElement.getAttribute('mana_production_bitvector'));
				//Ignore colorless production
				if (manaProductionBitVector >= 32)
				{
					manaProductionBitVector = manaProductionBitVector - 32;
				}
				//Lands come after nonlands
				return (colorOrderLookupTable[manaProductionBitVector] + 100);
			} else {
				var cost = new ManaCost(cardElement.getAttribute('casting_cost'));
				return colorOrderLookupTable[cost.colorBitVector];
			}
		}

		function getTypeOrder(cardElement)
		{
			if (cardElement.getAttribute('land') == 'true') {
				return -1;
			} else if (cardElement.getAttribute('creature') == 'true') {
				return 1;
			} else if (cardElement.getAttribute('planeswalker') == 'true') {
				return 2;
			} else if (cardElement.getAttribute('artifact') == 'true') {
				return 3;
			} else if (cardElement.getAttribute('enchantment') == 'true') {
				return 4;
			} else if (cardElement.getAttribute('sorcery') == 'true') {
				return 5;
			} else if (cardElement.getAttribute('instant') == 'true') {
				return 6;
			} else {
				return 7;
			}
		}

		function sortSideboard()
		{
			//Get all the elements in the sideboard
			var elementsOnSideboard = document.getElementById('sideboard').getElementsByTagName('*');
			
			//Figure out which of the elements are cards
			var cardsToSort = [];
			var i = 0;
			for (i = 0; i < elementsOnSideboard.length; ++i)
			{
				if (hasClass(elementsOnSideboard[i], "card"))
				{
					cardsToSort.push(elementsOnSideboard[i]);
				}
			}

			//Sort the cards by cost
			cardsToSort.sort(
				function(a,b)
				{
					var ret = getColorOrder(a) - getColorOrder(b);
					if (ret == 0)
					{
						ret = getTotalCost(a) - getTotalCost(b);
						if (ret == 0)
						{
							var aName = a.getAttribute("name");
							var bName = b.getAttribute("name");
							if (aName != null && bName != null)
							{
								ret = aName.localeCompare(bName);
							} else {
								ret = 0;
							}
						}
					}
					return ret;
				}
			);

			var xOffset = 10;
			var yOffset = 10;

			for (i = 0; i < cardsToSort.length; ++i)
			{
				//Reveal the card
				cardsToSort[i].src = cardsToSort[i].getAttribute("front");
				//Put it into the deck
				cardsToSort[i].style.top = yOffset + nameHeight * i + 'px';
				cardsToSort[i].style.left = xOffset + 'px';
				//Untap
				cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				//Bring it in front of the other elements
				cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
			}
		}

		function costSort()
		{
			//Deselect any selected cards
			deselectAll();
			deleteAllCounters()

			//Get all the elements on the playmat
			var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

			//Figure out which of the elements are cards
			var cardsToSort = [];
			var i = 0;
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				if (hasClass(elementsOnMat[i], "card"))
				{
					cardsToSort.push(elementsOnMat[i]);
				}
			}

			//Sort the cards by cost
			cardsToSort.sort(
				function(a,b){
					var ret = getTotalCost(a) - getTotalCost(b);
					if (ret == 0)
					{
						ret = getColorOrder(a) - getColorOrder(b);
						if (ret == 0)
						{
							var aName = a.getAttribute("name");
							var bName = b.getAttribute("name");
							if (aName != null && bName != null)
							{
								ret = aName.localeCompare(bName);
							} else {
								ret = 0;
							}
						}
					}
					return ret;
				}
			);

			//Arrange the cards on the mat
			var stackNum = 0;
			var previousCardValue = -9000;
			var stackHeight = 0;

			var xOffset = 50;
			var yOffset = 100;

			var stackSpacing = cardWidth + 10;

			for (i = 0; i < cardsToSort.length; ++i)
			{
				//Is this card of a different class?
				if (getTotalCost(cardsToSort[i]) != previousCardValue)
				{
					//Create a new stack
					stackNum++;
					stackHeight = 0;
					previousCardValue = getTotalCost(cardsToSort[i]);
				}
				//Add this card to the stack
				//Reveal the card
				cardsToSort[i].src = cardsToSort[i].getAttribute("front");
				//Put it into the deck
				cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
				cardsToSort[i].style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
				//Untap
				cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				//Bring it in front of the other elements
				cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
				stackHeight++;
			}

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';
		}

		function typeSort()
		{
			//Deselect any selected cards
			deselectAll();
			deleteAllCounters()

			//Get all the elements on the playmat
			var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

			//Figure out which of the elements are cards
			var cardsToSort = [];
			var i = 0;
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				if (hasClass(elementsOnMat[i], "card"))
				{
					cardsToSort.push(elementsOnMat[i]);
				}
			}

			//Sort the cards by type, then cost, then color, then name
			cardsToSort.sort(
				function(a,b){
					var ret = getTypeOrder(a) - getTypeOrder(b);
					if (ret == 0)
					{
						ret = getTotalCost(a) - getTotalCost(b);
						if (ret == 0)
						{
							ret = getColorOrder(a) - getColorOrder(b);
							if (ret == 0)
							{
								var aName = a.getAttribute("name");
								var bName = b.getAttribute("name");
								if (aName != null && bName != null)
								{
									ret = aName.localeCompare(bName);
								} else {
									ret = 0;
								}
							}
						}
					}
					return ret;
				}
			);

			//Arrange the cards on the mat
			var stackNum = 0;
			var previousCardValue = -9000;
			var stackHeight = 0;

			var xOffset = 50;
			var yOffset = 100;

			var stackSpacing = cardWidth + 10;

			for (i = 0; i < cardsToSort.length; ++i)
			{
				//Is this card of a different class?
				if (getTypeOrder(cardsToSort[i]) != previousCardValue)
				{
					//Create a new stack
					stackNum++;
					stackHeight = 0;
					previousCardValue = getTypeOrder(cardsToSort[i]);
				}
				//Add this card to the stack
				//Reveal the card
				cardsToSort[i].src = cardsToSort[i].getAttribute("front");
				//Put it into the deck
				cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
				cardsToSort[i].style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
				//Untap
				cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				//Bring it in front of the other elements
				cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
				stackHeight++;
			}

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';
		}

		function colorSort()
		{
			//Deselect any selected cards
			deselectAll();
			deleteAllCounters()

			//Get all the elements on the playmat
			var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

			//Figure out which of the elements are cards
			var cardsToSort = [];
			var i = 0;
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				if (hasClass(elementsOnMat[i], "card"))
				{
					cardsToSort.push(elementsOnMat[i]);
				}
			}

			//Sort the cards by color, then cost, then name
			cardsToSort.sort(
				function(a,b)
				{
					var ret = getColorOrder(a) - getColorOrder(b);
					if (ret == 0)
					{
						ret = getTotalCost(a) - getTotalCost(b);
						if (ret == 0)
						{
							var aName = a.getAttribute("name");
							var bName = b.getAttribute("name");
							if (aName != null && bName != null)
							{
								ret = aName.localeCompare(bName);
							} else {
								ret = 0;
							}
						}
					}
					return ret;
				}
			);

			//Figure out the necessary columns
			var columns = [];
			for (i = 0; i < 64; ++i)
			{
				columns.push(-1);
			}

			function getColumnId(colorOrder)
			{
				colorOrder = colorOrder - 1;
				if (colorOrder >= 100) {
					return colorOrder - 100;
				} else {
					return colorOrder;
				}
			}

			//Figure out which columns will have cards
			for (i = 0; i < cardsToSort.length; ++i)
			{
				columns[getColumnId(getColorOrder(cardsToSort[i]))] = 1;
			}

			//Number off the columns that have cards
			var columnNum = 0;
			for (i = 0; i < columns.length; ++i)
			{
				if (columns[i] == 1){
					columns[i] = columnNum;
					columnNum++;
				}
			}

			//Arrange the cards on the mat
			var previousCardValue = -9000;
			var row1Height = 0;
			var stackHeight = 0;
			var xOffset = 50;
			var yOffset = 100;
			var stackSpacing = cardWidth + 10;

			for (i = 0; i < cardsToSort.length; ++i)
			{
				//Is this card of a different color?
				if ( getColorOrder(cardsToSort[i]) != previousCardValue )
				{
					stackHeight = 0;
					previousCardValue = getColorOrder(cardsToSort[i]);
				}
				
				//Add this card to the stack
				//Reveal the card
				cardsToSort[i].src = cardsToSort[i].getAttribute("front");
				//Put it in its column
				cardsToSort[i].style.left = xOffset + stackSpacing * columns[getColumnId(getColorOrder(cardsToSort[i]))] + 'px';
				//Untap
				cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				
				//Check if this is part of row 1
				if ( getColorOrder(cardsToSort[i]) < 100 )
				{
					cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
					stackHeight++;
					//Save the height of the largest stack in row 1
					if (stackHeight > row1Height)
					{
						row1Height = stackHeight;
					}
				} else {
					cardsToSort[i].style.top = yOffset + cardsToSort[i].clientHeight +  nameHeight * row1Height + nameHeight * stackHeight + 'px';
					stackHeight++;
				}

				//Bring it in front of the other elements
				cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
			}

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';
		}

		function purposeSort()
		{
			//Deselect any selected cards
			deselectAll();
			deleteAllCounters()

			//Get all the elements on the playmat
			var elementsOnMat = document.getElementById('playmat').getElementsByTagName('*');

			//Figure out which of the elements are cards
			var cardsToSort = [];
			var i = 0;
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				if (hasClass(elementsOnMat[i], "card"))
				{
					cardsToSort.push(elementsOnMat[i]);
				}
			}

			//Sort the cards by purpose, then cost, then color, then name
			cardsToSort.sort(
				function(a,b){
					var aPurpose = a.getAttribute("purpose");
					var bPurpose = b.getAttribute("purpose");
					if (aPurpose != null && bPurpose != null)
					{
						ret = aPurpose.localeCompare(bPurpose);
					} else {
						ret = 0;
					}
					if (ret == 0)
					{
						ret = getTotalCost(a) - getTotalCost(b);
						if (ret == 0)
						{
							ret = getColorOrder(a) - getColorOrder(b);
							if (ret == 0)
							{
								var aName = a.getAttribute("name");
								var bName = b.getAttribute("name");
								if (aName != null && bName != null)
								{
									ret = aName.localeCompare(bName);
								} else {
									ret = 0;
								}
							}
						}
					}
					return ret;
				}
			);

			//Arrange the cards on the mat
			var stackNum = 0;
			var previousCardValue = "plumbus";
			var stackHeight = 0;

			var xOffset = 50;
			var yOffset = 100;

			var stackSpacing = cardWidth + 10;

			for (i = 0; i < cardsToSort.length; ++i)
			{
				//Is this card of a different class?
				if (cardsToSort[i].getAttribute("purpose") != previousCardValue)
				{
					//Create a new stack
					stackNum++;
					stackHeight = 0;
					previousCardValue = cardsToSort[i].getAttribute("purpose");
				}
				//Add this card to the stack
				//Reveal the card
				cardsToSort[i].src = cardsToSort[i].getAttribute("front");
				//Put it into the deck
				cardsToSort[i].style.top = yOffset + nameHeight * stackHeight + 'px';
				cardsToSort[i].style.left = xOffset + stackSpacing * (stackNum - 1) + 'px';
				//Untap
				cardsToSort[i].className = cardsToSort[i].className.replace( /(?:^|\s)rotated(?!\S)/g , '' );
				//Bring it in front of the other elements
				cardsToSort[i].parentNode.appendChild(cardsToSort[i]);
				stackHeight++;
			}

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';
		}

		function deleteSelection()
		{

			document.getElementById('magnified card view').src = "";
			hideCardInfoMenu();
			
			//Get all the elements in the selection
			var elementsInSelection = document.getElementById('selector').getElementsByTagName('*');

			//Delete all the elements
			var elementsToDelete = [];
			for (i = 0; i < elementsInSelection.length; ++i)
			{
				elementsToDelete.push(elementsInSelection[i]);
			}

			for (i = 0; i < elementsToDelete.length; ++i)
			{
				elementsToDelete[i].parentNode.removeChild(elementsToDelete[i]);
			}
		}


		//Main
		window.onload = function() {
			//Create some cards for testing
			document.onmousemove=dragElement;
			document.onmouseup=stopDrag;
			document.getElementById("card info popup").addEventListener("mouseleave", hideCardInfoMenu);
			document.getElementById("magnified card view").addEventListener("mousedown", hideCardInfoMenu);
			document.getElementById("playmat").addEventListener("mousedown", startSelection);
			document.getElementById("land checkbox").onclick = permanentTypeSelected;
			document.getElementById("creature checkbox").onclick = permanentTypeSelected;
			document.getElementById("planeswalker checkbox").onclick = permanentTypeSelected;
			document.getElementById("artifact checkbox").onclick = permanentTypeSelected;
			document.getElementById("enchantment checkbox").onclick = permanentTypeSelected;
			document.getElementById("sorcery checkbox").onclick = sorceryTypeSelected;
			document.getElementById("instant checkbox").onclick = instantTypeSelected;

			//var ggWentworth = CardElement("http://magiccards.info/scans/en/nph/37.jpg");

			var sideboard = document.getElementById("sideboard");
			sideboard.addEventListener("mouseover", mouseEnterSideboard);
			sideboard.addEventListener("mouseout", mouseLeaveSideboard);

			//Go through all the elements on the playmat and set up their javascript functions
			var elementsOnMat = document.getElementById("playmat").getElementsByTagName('*');
			var i, element;
			for (i = 0; i < elementsOnMat.length; ++i)
			{
				element = elementsOnMat[i];
				//Set up cards
				if (hasClass(element,'card')){
					element.addEventListener("mousedown", mouseDownCard);
					element.addEventListener("mouseup", mouseUpCard);
					element.addEventListener("mouseenter", mouseEnterCard);
					element.addEventListener("mouseleave", mouseLeaveCard);
				}
			}

			deselectAll();

			//Resize document to fit
			document.body.style.width = '100%';
			document.body.style.height = '100%';
			document.body.style.width = document.body.scrollWidth + 'px';
			document.body.style.height = document.body.scrollHeight + 'px';

			//var bsColossus = CardElement("http://magiccards.info/scans/en/mbs/99.jpg");
		}
		
	</script>
</body>
</html>